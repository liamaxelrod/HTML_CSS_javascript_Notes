<!-- File name: N/Rust/Arrays.html -->

<template> <!-- Rust: Data Structures (Array, Vector, Tuple, HashMap, Structs, Enums) -->

  <div class="bubble">

    <!-- 1. CODE BLOCKS -->
    <h3>Rust Data Structures: Common Types</h3>
    <div class="code_block">
      <code>
        <!-- C1: Array -->
        // Array: fixed-size list of same-type values <br>
        // Define an array of 7 integers (i32), one for each day of the week <br>
        <span class="C1">let temperatures: [i32; 7] = [70, 72, 68, 65, 74, 73, 71];</span><br>
        // Access a single value by index (0 = Monday) <br>
        <span class="C1">println!("Monday temperature: {}", temperatures[0]);</span><br>
        // Loop over array with index (day) and value (temp) <br>
        <span class="C1">for (day, temp) in temperatures.iter().enumerate() {</span><br>
        &nbsp;&nbsp;// Print each day‚Äôs number and its temperature <br>
        <span class="C1">&nbsp;&nbsp;println!("Day {}: {}¬∞F", day + 1, temp);</span><br>
        <span class="C1">}</span><br><br>

        <!-- C2: Vector (Vec) -->
        // Vector: growable list of same-type values <br>
        // Start with a shopping list containing 3 items <br>
        <span class="C2">let mut shopping_list: Vec<&str> = vec!["eggs", "milk", "bread"];</span><br>
        // Add new items at runtime (vectors can grow) <br>
        <span class="C2">shopping_list.push("apples");</span><br>
        <span class="C2">shopping_list.push("orange juice");</span><br>
        // Loop through vector by reference to print each item <br>
        <span class="C2">for item in &shopping_list { println!("- {}", item); }</span><br><br>

        <!-- C3: Tuple -->
        // Tuple: group different types together <br>
        // A tuple can hold different types: string, number, boolean <br>
        <span class="C3">let user_profile: (&str, i32, bool) = ("Alice", 30, true);</span><br>
        // Access tuple fields with .0, .1, .2 etc. <br>
        <span class="C3">println!("Name: {}, Age: {}, Active: {}", user_profile.0, user_profile.1, user_profile.2);</span><br>
        // Function that returns a tuple (min, max) from a slice of numbers <br>
        <span class="C3">fn min_max(numbers: &[i32]) -> (i32, i32) {</span><br>
        &nbsp;&nbsp;// Start with the first number as both min and max <br>
        <span class="C3">&nbsp;&nbsp;let mut min = numbers[0]; let mut max = numbers[0];</span><br>
        &nbsp;&nbsp;// Loop through and update min/max <br>
        <span class="C3">&nbsp;&nbsp;for &num in numbers { if num < min { min = num; } if num > max { max = num; } }</span><br>
        &nbsp;&nbsp;// Return a tuple (min, max) <br>
        <span class="C3">&nbsp;&nbsp;(min, max)</span><br>
        <span class="C3">}</span><br>
        // Example use: destructure the returned tuple <br>
        <span class="C3">let numbers = [4, 7, 1, 9]; let (min, max) = min_max(&numbers);</span><br>
        <span class="C3">println!("Min: {}, Max: {}", min, max);</span><br><br>

        <!-- C4: HashMap -->
        // HashMap: key-value lookup <br>
        // Bring HashMap type into scope <br>
        <span class="C4">use std::collections::HashMap;</span><br>
        // Create a mutable HashMap to store student scores <br>
        <span class="C4">let mut scores = HashMap::new();</span><br>
        // Insert names (keys) with their scores (values) <br>
        <span class="C4">scores.insert("Alice", 90); scores.insert("Bob", 75); scores.insert("Charlie", 82);</span><br>
        // Get a value safely with .get(), returns Option <br>
        <span class="C4">if let Some(score) = scores.get("Alice") { println!("Alice scored: {}", score); }</span><br>
        // Iterate through all key-value pairs <br>
        <span class="C4">for (name, score) in &scores { println!("{}: {}", name, score); }</span><br><br>

        <!-- C5: Structs -->
        // Struct: custom type with named fields <br>
        // Define a Point struct with two integer fields <br>
        <span class="C5">struct Point { x: i32, y: i32 }</span><br>
        // Create a Point instance <br>
        <span class="C5">let p1 = Point { x: 10, y: 20 };</span><br>
        // Access struct fields with dot notation <br>
        <span class="C5">println!("Point coordinates: ({}, {})", p1.x, p1.y);</span><br>
        // Define another struct for a more complex type <br>
        <span class="C5">struct Person { name: String, age: u8, active: bool }</span><br>
        // Create a Person instance with field values <br>
        <span class="C5">let user = Person { name: "Bob".to_string(), age: 25, active: true };</span><br>
        <span class="C5">println!("{} is {} years old", user.name, user.age);</span><br><br>

        <!-- C6: Enums -->
        // Enum: type with multiple named variants <br>
        // Define an enum for traffic light states <br>
        <span class="C6">enum TrafficLight { Red, Yellow, Green }</span><br>
        // Create a variable holding a variant of the enum <br>
        <span class="C6">let light = TrafficLight::Red;</span><br>
        // Match enum value to decide behavior <br>
        <span class="C6">match light {</span><br>
        &nbsp;&nbsp;// Each arm describes what to do for a variant <br>
        <span class="C6">&nbsp;&nbsp;TrafficLight::Red => println!("Stop!"),</span><br>
        <span class="C6">&nbsp;&nbsp;TrafficLight::Yellow => println!("Slow down."),</span><br>
        <span class="C6">&nbsp;&nbsp;TrafficLight::Green => println!("Go!"),</span><br>
        <span class="C6">}</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUTS -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; Monday: 70, Tuesday: 72, ‚Ä¶ up to 7 days</span><br>
      <span class="dot d2"></span><span> &rarr; - eggs, - milk, - bread, - apples, - orange juice</span><br>
      <span class="dot d3"></span><span> &rarr; Name: Alice, Age: 30, Active: true; Min: 1, Max: 9</span><br>
      <span class="dot d4"></span><span> &rarr; Alice: 90, Bob: 75, Charlie: 82</span><br>
      <span class="dot d5"></span><span> &rarr; Point coordinates: (10, 20); Bob is 25 years old</span><br>
      <span class="dot d6"></span><span> &rarr; Stop! (Red), Slow down. (Yellow), Go! (Green)</span><br>
    </div>

    <!-- 3. EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>Array</code></span><span> ‚Äì An array is a fixed-size list of items that are all the same type. Use when you know the number of items will never change. Example: the 12 months in a year, or the 7 days of the week. Arrays give very predictable memory usage, which makes them fast and efficient.</span><br><br>

      <span class="C2"><code>Vector (Vec)</code></span><span> ‚Äì A vector is a growable list of items of the same type. Use when the number of items is not known ahead of time or changes during the program. Example: a shopping cart in an online store (customers can keep adding and removing items), or a log of events as they happen. Vectors manage memory for you, which makes them flexible and safe.</span><br><br>

      <span class="C3"><code>Tuple</code></span><span> ‚Äì A tuple groups values of different types into a single unit. Use when you need to combine a few different pieces of data together without creating a custom type. Example: returning both a status code and a message from a function, or storing a user‚Äôs profile as (name, age, active_status). Tuples are quick and convenient when the data is small and temporary.</span><br><br>

      <span class="C4"><code>HashMap</code></span><span> ‚Äì A HashMap stores data as key‚Äìvalue pairs for fast lookups. Use when you want to quickly find a value by its key. Example: a dictionary where words (keys) map to definitions (values), or storing student IDs (keys) with their grades (values). HashMaps are great when your data needs to grow dynamically and when direct access by a unique key is important.</span><br><br>

      <span class="C5"><code>Struct</code></span><span> ‚Äì A struct lets you create your own custom data type with named fields. Use when you want to model something meaningful in your program. Example: a <code>User</code> with a name, age, and email, or a <code>Point</code> with x and y coordinates. Structs make your code easier to read and help represent real-world objects in a clear, structured way.</span><br><br>

      <span class="C6"><code>Enum</code></span><span> ‚Äì An enum represents a value that can be one of several options. Use when something can exist in different states or forms. Example: traffic lights with <code>Red</code>, <code>Yellow</code>, and <code>Green</code>, or different commands in a program like <code>Start</code>, <code>Stop</code>, <code>Pause</code>. Enums combined with <code>match</code> let you safely handle every possible case.</span><br><br>

       <span class="C7"><code>Array</code></span><span> ‚Äì Think of a row of mailboxes with a fixed number of slots. Each slot holds the same type of item (like numbers or names). You cannot add or remove slots. Use this when you know exactly how many items you need and they won‚Äôt change.</span><br>
      <span class="C7"><code>Vector (Vec)</code></span><span> ‚Äì Like a backpack that can hold any number of items. You can add or remove items freely, but everything inside is the same type (all apples, all numbers). Use it when the number of items can change while the program runs.</span><br>
      <span class="C7"><code>Tuple</code></span><span> ‚Äì Imagine a single envelope that holds different things together: a photo, a letter, and a coin. Each thing can be a different type. Tuples are not multiple lists, they are **one bundle of different things**. Use it when you want to keep a few related pieces of data together temporarily.</span><br>
      <span class="C7"><code>HashMap</code></span><span> ‚Äì Like a dictionary: you have a word (key) and its definition (value). You can add or remove entries anytime. Use it when you want to look things up by a label or key quickly.</span><br>
      <span class="C7"><code>Struct</code></span><span> ‚Äì Like a form you fill out with labeled fields: name, age, email. Each field has a name and a type. Unlike a HashMap, the fields are fixed and named ahead of time, so everyone knows exactly what data exists. Use it to model real-world objects clearly and safely.</span><br>
      <span class="C7"><code>Enum</code></span><span> ‚Äì Think of a light switch with three positions: Red, Yellow, Green. A variable can only ever be one of these states at a time. Unlike a Struct or HashMap, you don‚Äôt store multiple pieces of information; you **choose one from several options**. Use it when something must always be one of a defined set of possibilities.</span><br>

      <!-- 3.2 NOTES -->
      <h3>Notes:</h3>
      <span>- Arrays are simple and efficient, but they cannot grow in size.</span><br>
      <span>- Vectors are more flexible because they can grow or shrink as needed.</span><br>
      <span>- Tuples are lightweight and temporary, while structs give names to fields for readability and long-term use.</span><br>
      <span>- HashMaps are the go-to tool when you need fast lookups by a unique key.</span><br>
      <span>- Structs model data with properties, while enums model situations with clear choices.</span><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <h3>Concept & Spirit:</h3>
      <span>- Rust encourages Arrays for fixed-size data because it guarantees efficient memory usage and predictable behavior.</span><br>
      <span>- Rust encourages Vectors for dynamic lists, giving flexibility without sacrificing safety, so beginners learn safe memory growth.</span><br>
      <span>- Tuples are lightweight, quick to use, and allow bundling of different types without creating a full type, teaching beginners simplicity and efficiency.</span><br>
      <span>- HashMaps show how to handle dynamic, key-based collections safely, emphasizing lookup efficiency and ownership rules.</span><br>
      <span>- Structs teach design and clarity: defining shapes for your data, modeling real-world objects, and writing readable, maintainable code.</span><br>
      <span>- Enums teach explicit state handling, showing how Rust enforces exhaustive, safe logic for variables that can be exactly one of several choices.</span><br>
      <span>- Beginner mindset: Always choose the structure that matches the real-world requirements of your data, consider mutability, ownership, and safety, and leverage Rust‚Äôs compiler to prevent mistakes. Think: ‚ÄúWhat is this data? How will it change? How can Rust help me handle it safely?‚Äù</span><br>
    </div>

  </div>
</template>

<template> <!-- RUST: Strings -->

  <div class="bubble">

    <!-- 1. CODE BLOCKS -->
    <h3>Topic Title: Rust Strings ‚Äì Working with &str and String</h3>
    <div class="code_block">
      <code>
        <!-- Section 1 -->
        // String slices (&str) <br>
        <span class="C1">let greeting: &str = "Hello";</span><br><br>

        <!-- Section 2 -->
        // Create a String from &str <br>
        <span class="C2">let s1 = "Hi".to_string();</span><br>
        <span class="C2">let s2 = String::from("Hola");</span><br><br>

        <!-- Section 3 -->
        // Change a mutable String <br>
        <span class="C3">let mut s3 = String::from("Hello");</span><br>
        <span class="C3">&nbsp;&nbsp;s3.push_str(", world!");</span><br><br>

        <!-- Section 4 -->
        // Concatenate with + and format! <br>
        <span class="C4">let s4 = s1 + &s2;</span><br>
        <span class="C4">let s5 = format!("{} {}", s2, s3);</span><br><br>

        <!-- Section 5 -->
        // Find String length <br>
        <span class="C5">let length = s5.len();</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUTS -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> ‚Üí Fixed slice "Hello"</span><br>
      <span class="dot d2"></span><span> ‚Üí Creates owned Strings: "Hi", "Hola"</span><br>
      <span class="dot d3"></span><span> ‚Üí Mutated string becomes "Hello, world!"</span><br>
      <span class="dot d4"></span><span> ‚Üí Concatenated: "HiHola" and "Hola Hello, world!"</span><br>
      <span class="dot d5"></span><span> ‚Üí Length of string in bytes (e.g., 18)</span><br>
    </div>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>&str</code></span><span> ‚Äì Pronounced ‚Äústring slice.‚Äù Think of it as a window into some text that already exists. You can look through the window and read the words, but you don‚Äôt own the house, so you can‚Äôt knock down walls or expand it. That‚Äôs why slices like <code>"Hello"</code> are fixed and unchangeable.</span><br><br>

      <span class="C2"><code>String</code></span><span> ‚Äì A <code>String</code> is like moving the text into your own house. Now you own it, and you can rearrange it however you want. You can build more rooms (add characters) or repaint walls (modify the content). That‚Äôs why <code>to_string()</code> and <code>String::from()</code> both ‚Äútake‚Äù the borrowed slice and give you a fresh owned <code>String</code> that you control.</span><br><br>

      <span class="C3"><code>mut</code> + <code>push_str()</code></span><span> ‚Äì Rust doesn‚Äôt let you change things unless you clearly say they‚Äôre mutable (<code>mut</code>). Declaring <code>mut s3</code> is like saying ‚Äúthis string is flexible.‚Äù Then <code>push_str()</code> works like taping more paper onto the end of a scroll. Each time you call it, the string grows.</span><br><br>

      <span class="C4"><code>Concatenate</code></span><span> ‚Äì The word ‚Äúconcatenate‚Äù simply means ‚Äúto join things together end-to-end.‚Äù In strings, it means gluing words one after another. The <code>+</code> operator does this, but with a catch: the first string is consumed (Rust gives up ownership of it) and then adds a borrowed piece (<code>&str</code>) onto the end. The <code>format!</code> macro is safer and cleaner‚Äîit doesn‚Äôt take ownership away and works with multiple values at once, like filling in blanks in a sentence.  
      Why both? The <code>+</code> operator is quick and low-level, good for two pieces. <code>format!</code> is the practical, everyday choice when building longer text.</span><br><br>

      <span class="C5"><code>.len()</code></span><span> ‚Äì This gives the length of the string, but in bytes, not characters. Why? Because Rust strings are UTF-8, which means some characters (like emoji or non-English letters) take more than one byte. For example, "a" is 1 byte, but "√©" is 2 bytes, and "üòä" is 4 bytes. This matters because if you assume <code>.len()</code> always means ‚Äúnumber of letters,‚Äù you can accidentally cut a character in half and corrupt the string. To count human-readable characters, use <code>.chars().count()</code>.</span><br><br>

      <span class="C6"><code>to_string()</code> vs <code>String::from()</code></span><span> ‚Äì These two are twins: they both convert a <code>&str</code> into an owned <code>String</code>. Which one you use is mostly personal style. Many Rustaceans prefer <code>to_string()</code> when starting from a literal (e.g. <code>"Hi".to_string()</code>) and <code>String::from()</code> when they want to be more explicit about ownership. Functionally, they‚Äôre the same.</span><br><br>

      <!-- 3.2 NOTES -->
      <h3>Notes:</h3>
      <span>- In Rust, ownership vs borrowing is a big deal. When you use <code>+</code>, the first <code>String</code> is moved and can‚Äôt be used anymore‚ÄîRust prevents hidden memory leaks by making ownership rules visible in code.</span><br>
      <span>- If you come from another language (like Python or JavaScript), you might expect all strings to be easy-to-edit. Rust forces you to say whether the data is borrowed (<code>&str</code>) or owned (<code>String</code>) so you know who controls the memory.</span><br>
      <span>- Rust‚Äôs strictness around mutability (<code>mut</code>) prevents accidental bugs where data changes unexpectedly. You always know which variables are frozen and which are flexible.</span><br>
      <span>- UTF-8 encoding is powerful because it supports every language and emoji, but it also means ‚Äúlength in bytes‚Äù is not always equal to ‚Äúlength in characters.‚Äù Rust makes you aware of this so you write safer, international-friendly code.</span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <h3>Concept & Spirit:</h3>
      <span>Rust‚Äôs string system may look strict at first, but it‚Äôs designed to teach you *who owns your data* and *what costs are being paid*. The reason these rules exist isn‚Äôt to slow you down‚Äîit‚Äôs to protect you from the hidden bugs other languages allow.  
      <br><br>
      ‚Ä¢ <code>&str</code> exists for efficiency: borrow when you don‚Äôt need to copy. <br> 
      ‚Ä¢ <code>String</code> exists for flexibility: own it when you need to grow or keep it.  <br>
      ‚Ä¢ <code>mut</code> ensures changes are deliberate.  <br>
      ‚Ä¢ <code>+</code> shows you ownership transfer; <code>format!</code> lets you build safely.  <br>
      ‚Ä¢ <code>.len()</code> shows you how Rust respects real encoding, instead of pretending all characters are equal.  <br><br>

      **Big picture:** Strings are one of the first places Rust shows its philosophy‚Äîmemory safety, clarity, and honesty about costs. Once you understand strings, you start to understand how Rust approaches everything else: don‚Äôt hide the details, make them explicit so your code is predictable and safe.</span>
    </div>

  </div>
</template>



