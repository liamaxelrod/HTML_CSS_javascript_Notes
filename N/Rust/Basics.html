<!-- File name: N/NRust/Basics.html -->

<template> <!-- Rust: Basics -->
  <div class="bubble">

    <h3>Rust Code: Fundamentals:</h3>

    <!-- Code Block -->
    <div class="code_block">
      <!-- Comments -->
      <code>// Single-line comment</code><br>
      <span class="C1"><code>// This is a comment</code><br>
      <code>/* This is a block comment */</code></span><br><br>

      <!-- Variables -->
      <code>// Variables</code><br>
      <span class="C2"><code>let x = 5;          // immutable integer</code><br>
      <code>let mut y = 10;      // mutable integer</code></span><br><br>

      <!-- Data Types -->
      <code>// Data Types</code><br>
      <span class="C3"><code>let my_num: i32 = 5;</code><br>
      <code>let my_double: f64 = 5.99;</code><br>
      <code>let my_letter: char = 'D';</code><br>
      <code>let my_bool: bool = true;</code><br>
      <code>let my_text: &str = "Hello";</code></span><br><br>

      <code>// Type-inferred Data Types</code><br>
      <span class="C4"><code>let my_num = 5;</code><br>
      <code>let my_double = 5.99;</code><br>
      <code>let my_letter = 'D';</code><br>
      <code>let my_bool = true;</code><br>
      <code>let my_text = "Hello";</code></span><br><br>

      <!-- Printing -->
      <code>// Printing Examples</code><br>
      <span class="C5"><code>print!("Hello ");</code><br>
      <code>println!("World!");</code></span><br>
      <span class="C6"><code>let name = "Liam";</code><br>
      <code>println!("Hello, {}", name);</code></span><br>
      <span class="C6"><code>let age = 21;</code><br>
      <code>println!("{} is {} years old", name, age);</code></span><br>
      <span class="C6"><code>println!("First {0}, Second {1}, Again {0}", 10, 20);</code></span><br>
      <span class="C6"><code>println!("Hi {name}", name="Bob");</code></span><br><br>

      <!-- Constants -->
      <code>// Constants</code><br>
      <span class="C7"><code>const MAX_SPEED: i32 = 120;</code><br>
      <code>const PI: f64 = 3.14159;</code><br>
      <code>const MINUTES_PER_HOUR: i32 = 60;</code></span>
    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <span class="dot d5"></span><span> &rarr; Prints: Hello World!</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hello, Liam</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Liam is 21 years old</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: First 10, Second 20, Again 10</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hi Bob</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1">//, /* */</span><span> – Comments are ignored by the compiler. </span><br>
      <span>Example: You can write </span><code>// explain what x does</code><span> and it won’t affect the program.</span><br><br>

      <span class="C2">let / mut</span><span> – <code>let</code> creates a variable. By default it’s immutable (cannot change). </span><br>
      <span>Example: <code>let x = 5;</code> → trying <code>x = 6;</code> gives an error. </span><br>
      <span>Use <code>let mut y = 10;</code> if you want to change it later (<code>y = 20;</code> works).</span><br><br>

      <span class="C3">Explicit types</span><span> – You can declare the type directly. </span><br>
      <code>let my_num: i32 = 5;</code><span>, <code>let my_double: f64 = 5.99;</code>. </span><br>
      <span>This makes your code clearer and avoids mistakes (like wrong type assumptions).</span><br><br>

      <span class="C4">Type inference</span><span> – If you skip the type, Rust figures it out. </span><br>
      <code>let my_num = 5;</code><span> → compiler knows it’s an <code>i32</code>. </span><br>
      <code>let my_double = 5.99;</code><span> → compiler knows it’s an <code>f64</code>.</span><br>
      <span>You write the type explicitly if you want clarity, or when Rust can’t guess correctly.</span><br><br>

      <span class="C5">print!/println!()</span><span> – <code>print!</code> does not add a new line, <code>println!</code> does. </span><br><br>

      <span class="C6">Placeholders {}</span><span> – Pull values into your string. </span><br>
      <span>Example: </span><code>println!("Hello, {}", name);</code><span> → if <code>name = "Liam"</code>, prints <code>Hello, Liam</code>.</span><br>
      <span>You can use multiple placeholders: </span><code>println!("{} is {}", name, age);</code><br>
      <span>You can reuse positions: </span><code>{0}, {1}</code><br>
      <span>You can also name them: </span><code>println!("Hi {name}", name="Bob");</code><br><br>

      <span class="C7">const</span><span> – Constants never change and must always have a type. </span><br>
      <span>Example: </span><code>const PI: f64 = 3.14159;</code><span> → always the same, anywhere in your code.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. Variables declared with <code>let</code> are immutable unless <code>mut</code> is used.</span><br>
      <span>2. Constants (<code>const</code>) are always immutable and must have a type.</span><br>
      <span>3. Comparison between constants and variables:</span><br><br>

      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>Feature</th>
          <th>Constant (<code>const</code>)</th>
          <th>Variable (<code>let</code>)</th>
        </tr>
        <tr>
          <td>Can change?</td>
          <td>No</td>
          <td>Yes, if <code>mut</code> is used</td>
        </tr>
        <tr>
          <td>Type required?</td>
          <td>Yes (must be written)</td>
          <td>No (can be inferred)</td>
        </tr>
      </table><br>

      <span>4. Use constants for fixed values like <code>PI</code> or <code>MINUTES_PER_HOUR</code>.</span><br>
      <span>5. Use <code>let</code> / <code>mut</code> for values that may change during program execution.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>
      - Rust wants you to **be clear about what can change and what cannot**. Variables are immutable by default, and constants never change — this prevents mistakes.<br>
      - Types are explicit or inferred, but Rust makes you aware of what each value is. This helps avoid unexpected errors.<br>
      - Printing with placeholders shows that Rust separates **data** from **how it’s displayed**, making output safe and predictable.<br>
      - Overall, Rust encourages **writing safe, predictable, and clear code**. Every decision — whether a value can change, how it’s stored, and how it’s printed — is intentional. This is the “spirit” behind Rust.
    </span>
    </div>

  </div>
</template>

<template> <!-- Rust: Operations -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Code: Operators</h3>
    <div class="code_block">

      <!-- Arithmetic Operators -->
      <code>// Arithmetic Operators</code>
      <span class="C1"><br>
        <code>let sum = 5 + 3;</code><br>
        <code>let difference = 5 - 3;</code><br>
        <code>let product = 5 * 3;</code><br>
        <code>let quotient = 10 / 2;</code><br>
        <code>let remainder = 10 % 3;</code><br>
      </span><br>

      <!-- Assignment Operators -->
      <code>// Assignment Operators</code>
      <span class="C2"><br>
        <code>let mut x = 5;</code><br>
        <code>x += 3;</code><br>
        <code>x -= 2;</code><br>
        <code>x *= 4;</code><br>
        <code>x /= 2;</code><br>
        <code>x %= 2;</code><br>
      </span><br>

      <!-- Comparison Operators -->
      <code>// Comparison Operators</code>
      <span class="C3"><br>
        <code>5 == 5</code><br>
        <code>5 != 3</code><br>
        <code>7 > 3</code><br>
        <code>2 < 5</code><br>
        <code>5 >= 5</code><br>
        <code>3 <= 4</code><br>
      </span><br>

      <!-- Logical Operators -->
       <code>// Logical Operators</code>
      <span class="C4"><br>
        <code>true && false</code><br>
        <code>true || false</code><br>
        <code>!true</code><br>
      </span>

    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <!-- Arithmetic -->
      <span class="dot d1"></span><span> &rarr; 8</span><br>
      <span class="dot d1"></span><span> &rarr; 2</span><br>
      <span class="dot d1"></span><span> &rarr; 15</span><br>
      <span class="dot d1"></span><span> &rarr; 5</span><br>
      <span class="dot d1"></span><span> &rarr; 1</span><br>

      <!-- Assignment -->
      <span class="dot d2"></span><span> &rarr; x = 8 after x += 3</span><br>
      <span class="dot d2"></span><span> &rarr; x = 6 after x -= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 24 after x *= 4</span><br>
      <span class="dot d2"></span><span> &rarr; x = 12 after x /= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 0 after x %= 2</span><br>

      <!-- Comparison -->
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>

      <!-- Logical -->
      <span class="dot d4"></span><span> &rarr; false</span><br>
      <span class="dot d4"></span><span> &rarr; true</span><br>
      <span class="dot d4"></span><span> &rarr; false</span><br>
    </div>

      <!-- Explanation Section -->
      <h3>Explanation:</h3>
      <div class="explanation">

        <span class="C1">+</span> adds two numbers. 5 + 3 → 8.<br>
        <span class="C1">-</span> subtracts one number from another. 5 - 3 → 2.<br>
        <span class="C1">*</span> multiplies numbers. 5 * 3 → 15.<br>
        <span class="C1">/</span> divides numbers. 10 / 2 → 5.<br>
        <span class="C1">%</span> gives the remainder of a division. 10 % 3 → 1.<br><br>

        <span class="C2">=</span> assigns a value to a variable.<br>
        <span class="C2">+=</span> adds to the current value. x += 3 adds 3 to x.<br>
        <span class="C2">-=</span> subtracts from the current value.<br>
        <span class="C2">*=</span> multiplies the current value.<br>
        <span class="C2">/=</span> divides the current value.<br>
        <span class="C2">%=</span> replaces the value with the remainder of division.<br>
        Variables must be mutable (mut) to use these operators.<br><br>

        <span class="C3">==</span> checks if two values are equal. 5 == 5 → true.<br>
        <span class="C3">!=</span> checks if two values are not equal. 5 != 3 → true.<br>
        <span class="C3">&gt;</span> checks if the left value is greater than the right. 7 > 3 → true.<br>
        <span class="C3">&lt;</span> checks if the left value is less than the right. 2 < 5 → true.<br>
        <span class="C3">&gt;=</span> checks if the left value is greater than or equal to the right. 5 >= 5 → true.<br>
        <span class="C3">&lt;=</span> checks if the left value is less than or equal to the right. 3 <= 4 → true.<br><br>

        <span class="C4">&&</span> (AND) is true only if both values are true. true && false → false.<br>
        <span class="C4">||</span> (OR) is true if at least one value is true. true || false → true.<br>
        <span class="C4">!</span> (NOT) inverts a boolean value. !true → false.<br><br>

        <strong>Notes:</strong><br>
        Arithmetic operators work on numeric types (i32, f32, etc.).<br>
        Assignment operators require mutable variables.<br>
        Comparison and logical operators return boolean values.<br>
        Rust does not allow mixing numeric types without explicit casting.<br><br>

        <strong>Concept & Spirit of Rust:</strong><br>
        <span>
        - Rust makes you **think about your code carefully**. You must decide when a value can change (mutable) and when it cannot.<br>
        - All operations (math, assignment, comparison, logic) are **safe by default**. Rust won’t do hidden conversions or guesses like some other languages.<br>
        - Using <code>mut</code> shows clearly when a variable is allowed to change. This makes your program easier to understand and less likely to have mistakes.<br>
        - Boolean operations (true/false checks) are clear and predictable — no surprises.<br>
        - The overall idea is to write code that is **explicit, clear, and safe**, so you always know what the program is doing with your data.
      </span>

    </div>

  </div>
</template>

<template> <!-- RUST: mut, Ownership & Borrowing -->

  <div class="bubble">

    <!-- 1. CODE BLOCKS -->
    <h3>Rust: mut, Ownership & Borrowing</h3>
    <div class="code_block">
      <code>
        <!-- Ownership Rules -->
        // Ownership Rules <br>
        <span class="C1">let x = 5;</span><br>
        <span class="C1">let y = x; // x is moved to y</span><br><br>

        <!-- Clone -->
        // Clone <br>
        <span class="C2">let x = 5;</span><br>
        <span class="C2">let y = x.clone(); // explicitly clone value</span><br><br>

        <!-- Borrowing -->
        // Borrowing & References <br>
        <span class="C3">let s = String::from("hello");</span><br>
        <span class="C3">let r = &s; // borrow s</span><br><br>

        <!-- Mutable References -->
        // Mutable References <br>
        <span class="C4">let mut s = String::from("hello");</span><br>
        <span class="C4">&nbsp;&nbsp;let r = &mut s; // mutable borrow</span><br><br>

        <!-- Guest List Example: Clone, Borrow, Mut Borrow -->
        fn main() { <br>
        <span class="C5">&nbsp;&nbsp;let mut guest_list = String::from("Alice, Bob");</span><br><br>

        <span class="C5">&nbsp;&nbsp;// Clone → backup copy before editing</span><br>
        <span class="C5">&nbsp;&nbsp;let backup = guest_list.clone();</span><br><br>

        <span class="C5">&nbsp;&nbsp;// Borrow → read without taking ownership</span><br>
        <span class="C5">&nbsp;&nbsp;print_guest_count(&guest_list);</span><br><br>

        <span class="C5">&nbsp;&nbsp;// Mut Borrow → temporarily modify original list</span><br>
        <span class="C5">&nbsp;&nbsp;add_guest(&mut guest_list);</span><br><br>

        <span class="C5">&nbsp;&nbsp;println!("Updated list: {}", guest_list);</span><br>
        }<br><br>

        <span class="C5">fn print_guest_count(list: &String) {</span><br>
        <span class="C5">&nbsp;&nbsp;let count = list.split(", ").count();</span><br>
        <span class="C5">&nbsp;&nbsp;println!("Current guests: {}", count);</span><br>
        <span class="C5">}</span><br><br>

        <span class="C5">fn add_guest(list: &mut String) {</span><br>
        <span class="C5">&nbsp;&nbsp;list.push_str(", Carol");</span><br>
        <span class="C5">}</span>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUTS -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; x is no longer valid after moving to y</span><br>
      <span class="dot d2"></span><span> &rarr; x is still usable because we cloned it</span><br>
      <span class="dot d3"></span><span> &rarr; r can read s without taking ownership</span><br>
      <span class="dot d4"></span><span> &rarr; r can modify s safely when borrowed mutably</span><br>
      <span class="dot d5"></span><span> &rarr; Guest list example: clone → backup copy, borrow → check length, mut borrow → add guest</span><br>
    </div>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>let x = 5;</code></span>
      <span> – x owns the value 5. When we assign x to y, ownership moves to y, and x can no longer be used. Rust automatically frees memory safely when a value goes out of scope.</span><br>

      <span class="C2"><code>x.clone()</code></span>
      <span> – Cloning creates a full copy of the value so both x and y have independent ownership. Use cloning when you need to preserve the original value while giving a copy to another variable.</span><br>

      <span class="C3"><code>&s</code></span>
      <span> – Borrowing a reference lets you read a value without taking ownership. The original owner (s) keeps control, preventing accidental invalid memory access, while you can safely use the data temporarily.</span><br>

      <span class="C4"><code>&mut s</code></span>
      <span> – Mutable references allow you to modify a value without taking ownership. Rust ensures there’s only one mutable reference at a time, preventing conflicts and guaranteeing safe, predictable changes.</span><br>

      <span class="C5"><code>Guest List Example</code></span>
      <span> – Clone creates a backup copy of the guest list so the original is safe. Borrow lets a function check how many guests exist without taking ownership. Mutable borrow lets a function temporarily edit the list (adding a new guest) while ownership stays with main. This shows **when and why to use clone, borrow, and mut borrow** in practice.</span><br>

      <span class="C6"><code>Ownership Concept</code></span>
      <span> – Rust’s ownership system is the foundation for memory safety. It removes the need for a garbage collector, while preventing bugs like dangling pointers or double frees.</span><br>

      <span class="C7"><code>Borrowing Concept</code></span>
      <span> – Borrowing allows you to use or modify data safely without giving up ownership. It encourages thinking about who “owns” data at any time and avoids unnecessary cloning, making programs faster.</span><br>

      <span class="C8"><code>Why This Matters</code></span>
      <span> – By enforcing ownership and borrowing rules, Rust ensures memory is always valid and accessible only by permitted parts of your program, improving reliability and preventing subtle bugs common in other languages.</span><br><br>

      <!-- 3.2 NOTES -->
      <h3>Notes:</h3>
      <span>- Each value has exactly one owner unless borrowed.</span><br>
      <span>- Ownership ensures memory is freed automatically when out of scope.</span><br>
      <span>- Borrowing avoids expensive clones for large values.</span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <h3>Concept & Spirit:</h3>
      <span>- Unlike other coding languages, keep in mind you're always either owning a variable or borrowing a variable</span><br>
      <span>- Ownership is Rust’s way of managing memory safely without a garbage collector.</span><br>
      <span>- Borrowing encourages safe reuse of data without transferring ownership.</span><br>
      <span>- These rules prevent common bugs like dangling pointers or double frees and are part of what makes Rust fast and reliable.</span>
    </div>

  </div>
</template>




