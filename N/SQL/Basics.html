<!-- File name: N/SQL/Basics.html -->








<!-- chatGPT Questions by liam Disregard if I forgot to remove them. 
------------------------------------------------ 


-------------------------------------------------
-->

<!-- list
------------------------------------------------ 
1. SQL Foundations

SQL Tutorial / SQL Home

SQL Intro ✅
SQL Syntax ✅
SQL Comments ✅
SQL Operators 
SQL Data Types ✅

5. Combining Tables

SQL Joins
SQL Inner Join
SQL Left Join
SQL Right Join
SQL Full Join
SQL Self Join
SQL Union
SQL Union All

6. Modifying Data

SQL Insert Into
SQL Insert Into Select
SQL Update
SQL Delete
SQL Select Into

7. Database Design, Integrity & Safety

SQL Database
SQL Create DB
SQL Drop DB
SQL Backup DB
SQL Create Table
SQL Drop Table
SQL Alter Table
SQL Constraints
SQL Not Null
SQL Unique
SQL Primary Key
SQL Foreign Key
SQL Check
SQL Default
SQL Index
SQL Auto Increment
SQL Dates
SQL Views
SQL Stored Procedures
SQL Injection
SQL Hosting




-------------------------------------------------
-->

<!-- 



-->

<!--1. SQL Foundations -->
<!-- Mental focus: Basics -->
<template> <!-- SQL: Intro / Basics -->

  <div class="bubble">

    <h3>Template for SQL: basic tutorial on SQL.</h3>

    <h3>Original: Table</h3>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ID</th>
        <th>CustomerName</th>
        <th>ContactName</th>
        <th>Address</th>
        <th>City</th>
        <th>PostalCode</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>1</td>
        <td>Alfreds Futterkiste</td>
        <td>Maria Anders</td>
        <td>Obere Str. 57</td>
        <td>Berlin</td>
        <td>12209</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Ana Trujillo Emparedados</td>
        <td>Ana Trujillo</td>
        <td>Avda. de la Constitución 2222</td>
        <td>México D.F.</td>
        <td>05021</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Around the Horn</td>
        <td>Thomas Hardy</td>
        <td>120 Hanover Sq.</td>
        <td>London</td>
        <td>WA1 1DP</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- 1. CODE BLOCK -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code class="C1">
        SELECT * FROM Customers;
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>ID</th>
        <th>CustomerFullName</th>
        <th>ContactName</th>
        <th>Address</th>
        <th>City</th>
        <th>PostalCode</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>1</td>
        <td>Alfreds Futterkiste</td>
        <td>Maria Anders</td>
        <td>Obere Str. 57</td>
        <td>Berlin</td>
        <td>12209</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Ana Trujillo Emparedados</td>
        <td>Ana Trujillo</td>
        <td>Avda. de la Constitución 2222</td>
        <td>México D.F.</td>
        <td>05021</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Around the Horn</td>
        <td>Thomas Hardy</td>
        <td>Thomas Hardy</td>
        <td>London</td>
        <td>WA1 1DP</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      
      <span class="C1">
        The SQL statement <code>SELECT * FROM Customers;</code></span><span> tells the database to return
        all rows and all columns from the <code>Customers</code> table.<br>

      
        The table shown in the example output is exactly what already exists in the database.
        This query does not modify the data — it only reads and displays it.<br><br>

      
        SQL (Structured Query Language) is the language used to communicate with a database.
        You can think of it like giving clear instructions to a librarian about which information
        you want to see.<br><br>

        Using a cabinet as a analogy:<br>
        - The cabinet is the database.<br>
        - Each drawer is a table (like <code>Customers</code>).<br>
        - Each folder is a row (one customer).<br>
        - Each page in the folder is a column value (name, city, country).<br><br>

        Columns have data types, such as string, numeric, or date/time, which define what kind
        of values they can store. Every column must have a name and a data type.<br>

        SQL provides a small set of core commands, such as SELECT, INSERT, UPDATE, DELETE, and WHERE.
        These act as the basic “verbs” for working with data.<br>

        SQL keywords are not case-sensitive, meaning <code>SELECT</code> and <code>select</code>
        are treated the same. Some database systems require a semicolon at the end of each statement,
        especially when multiple statements are sent together.<br>

        In a web application, SQL is typically used by a server-side language (such as PHP or ASP)
        to retrieve data from the database, while HTML and CSS are responsible for displaying
        that data to the user.
      </span><br><br>


      <!-- 3.2 NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - Some databases are stricter about semicolons than others (MySQL often optional, Oracle required in scripts).<br>
        - ANSI compliance ensures basic SQL commands work similarly across systems.<br>
        - Data types vary slightly between systems; always check your RDBMS documentation.<br>
        - comment are made with /* text */ and -- text.
      </span><br><br>
      

      <!-- 3.3 CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - SQL is a declarative language: you describe WHAT you want, not HOW to get it.<br>
        - Understanding table structure is critical before writing queries; you must know rows, columns, and types.<br>
        - Early habits: always use consistent case for readability; semicolons help prevent multi-statement errors.
      </span>
    </div>

  </div>
</template>

<!-- 2. Retrieving Data -->
<!-- Mental focus: What does my result look like? -->
<template> <!-- SQL: SELECT, SELECT DISTINCT, SELECT TOP, ALIASES -->

  <div class="bubble">

    <h3>Template for SQL: SELECT, SELECT DISTINCT, SELECT TOP, ALIASES</h3>

    <!-- 0. TABLE EXAMPLE (Existing Data + Duplicate Row for DISTINCT) -->
    <h3>Original: Table</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ID</th>
        <th>CustomerName</th>
        <th>ContactName</th>
        <th>Address</th>
        <th>City</th>
        <th>PostalCode</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>1</td>
        <td>Alfreds Futterkiste</td>
        <td>Maria Anders</td>
        <td>Obere Str. 57</td>
        <td>Berlin</td>
        <td>12209</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Ana Trujillo Emparedados</td>
        <td>Ana Trujillo</td>
        <td>Avda. de la Constitución 2222</td>
        <td>México D.F.</td>
        <td>05021</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Around the Horn</td>
        <td>Thomas Hardy</td>
        <td>120 Hanover Sq.</td>
        <td>London</td>
        <td>WA1 1DP</td>
        <td>UK</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Around the Horn</td>
        <td>Sarah Smith</td>
        <td>88 Fleet Street</td>
        <td>London</td>
        <td>EC4Y 1DH</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <span class="C1">SELECT * FROM Customers;</span><br><br>

        <span class="C2">SELECT CustomerName, Country FROM Customers;</span><br><br>

        <!-- New C3: DISTINCT -->
        <span class="C3">SELECT DISTINCT CustomerName, Country FROM Customers;</span><br><br>

        <!-- Pushed down -->
        <span class="C4">SELECT TOP 2 CustomerName, Country FROM Customers;</span><br><br>

        <span class="C5">SELECT CustomerName AS Name, Country AS Location FROM Customers;</span>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- Output for C1 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>ID</th>
        <th>CustomerName</th>
        <th>ContactName</th>
        <th>Address</th>
        <th>City</th>
        <th>PostalCode</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>1</td>
        <td>Alfreds Futterkiste</td>
        <td>Maria Anders</td>
        <td>Obere Str. 57</td>
        <td>Berlin</td>
        <td>12209</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Ana Trujillo Emparedados</td>
        <td>Ana Trujillo</td>
        <td>Avda. de la Constitución 2222</td>
        <td>México D.F.</td>
        <td>05021</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Around the Horn</td>
        <td>Thomas Hardy</td>
        <td>120 Hanover Sq.</td>
        <td>London</td>
        <td>WA1 1DP</td>
        <td>UK</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Around the Horn</td>
        <td>Sarah Smith</td>
        <td>88 Fleet Street</td>
        <td>London</td>
        <td>EC4Y 1DH</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- Output for C2 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>CustomerName</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>Alfreds Futterkiste</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>Ana Trujillo Emparedados</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>Around the Horn</td>
        <td>UK</td>
      </tr>
      <tr>
        <td>Around the Horn</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- Output for C3: DISTINCT removes duplicates -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>CustomerName</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>Alfreds Futterkiste</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>Ana Trujillo Emparedados</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>Around the Horn</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- Output for C4: TOP -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>CustomerName</th>
        <th>Country</th>
      </tr>
      <tr>
        <td>Alfreds Futterkiste</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>Ana Trujillo Emparedados</td>
        <td>Mexico</td>
      </tr>
    </table>

    <!-- Output for C5: ALIASES -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5">
        <th>Name</th>
        <th>Location</th>
      </tr>
      <tr>
        <td>Alfreds Futterkiste</td>
        <td>Germany</td>
      </tr>
      <tr>
        <td>Ana Trujillo Emparedados</td>
        <td>Mexico</td>
      </tr>
      <tr>
        <td>Around the Horn</td>
        <td>UK</td>
      </tr>
      <tr>
        <td>Around the Horn</td>
        <td>UK</td>
      </tr>
    </table>

    <!-- 3. EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>SELECT * FROM Customers</code></span>
      <span> – Retrieves all columns from the <code>Customers</code> table.<br>
      The <code>SELECT</code> tells SQL that we want to read data.<br>
      The <code>*</code>symbol means “everything.” This is useful for exploring a table, but not ideal for production code.<br>
      The <code>FROM</code>tells SQL which table to read from.<br>
      The <code>Customers</code>is the table name.<br>
      </span><br>

      <span class="C2"><code>SELECT CustomerName, Country FROM Customers</code></span>
      <span>– This query asks the database to return two specific columns from the <code>Customers</code> table.<br>
      The structure might be different, but the commands are still coherent.<br>
      The <code>SELECT</code> tells SQL that we want to read data.<br>
      The <code>CustomerName</code> Specifies the first column to include in the result. (We still don't know the table)<br>
      The <code>,</code> It tells SQL that more than one column should be returned.<br>
      The <code>Country</code> Specifies the second column to include in the result.<br>
      The <code>FROM</code> tells SQL which table to read from.<br>
      The <code>Customers</code> is the table name.<br>
      </span><br>

      <!-- New C3: DISTINCT -->
      <span class="C3"><code>SELECT DISTINCT CustomerName, Country FROM Customers</code></span>
      <span> – The <code>DISTINCT</code> keyword tells SQL to return only unique rows.<br>
      In our example, there are two rows for "Around the Horn", but <code>DISTINCT</code> removes the duplicate.<br>
      It only focuses on the dulicates on that column, not for the other columns that may have differences.</span><br><br>

      <!-- C3: SELECT TOP -->
      <span class="C4"><code>SELECT TOP</code></span>
      <span>
      – The <code>SELECT TOP</code> clause is used to limit how many rows are returned by a query.<br>
      If not specified, it will just get the first data it reads from the table.<br>

      This makes <code>TOP</code> a performance-focused tool, not just a convenience feature.
      </span><br><br>

      <!-- C4: SQL ALIASES -->
      <span class="C5"><code>AS (Aliases)</code></span>
      <span>
      – SQL aliases allow you to temporarily rename a column or table for the duration of a query.<br>
      They do not change the database itself — only how the result is displayed.<br><br>

      Aliases are commonly used to:<br>
      - Make column names easier to read<br>
      - Shorten long table names<br>
      - Improve clarity when combining or transforming data<br><br>
      </span>

      <!-- NOTES -->
      <strong>Notes:</strong><br>
      <span>
      - <code>SELECT</code> only reads data; it never modifies the table.<br>
      - Query results behave like a temporary table that exists only for that query.<br>
      - Avoid <code>SELECT *</code> in real applications to reduce unnecessary data transfer.<br><br>

      - <code>SELECT TOP</code> is not supported by all database systems.<br>
      &nbsp;&nbsp;• SQL Server / MS Access → <code>TOP</code><br>
      &nbsp;&nbsp;• MySQL → <code>LIMIT</code><br>
      &nbsp;&nbsp;• Oracle → <code>FETCH FIRST n ROWS ONLY</code> or <code>ROWNUM</code><br><br>

      - Aliases do not change the database; they only affect the query result.<br>
      - When using spaces in aliases, wrap them in brackets or quotes.<br>
      - Aliases are useful for formatting, combining columns, and improving readability.<br>
      - Table aliases are especially important when working with multiple tables.<br>
      </span><br>

      <!-- CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
      - SQL is designed around asking clear questions about data, not writing step-by-step instructions.<br>
      - The <code>SELECT</code> statement reinforces precision: you explicitly state what data you want and nothing more.<br>
      - This approach naturally improves performance, readability, and safety by discouraging unnecessary data access.<br><br>

      - Features like <code>TOP</code> encourage intentional data limits, reinforcing the idea that queries should return only what is actually needed.<br>
      - SQL rewards thoughtful, well-scoped questions instead of retrieving full tables by default.<br><br>

      - Aliases emphasize that clarity matters just as much as correctness.<br>
      - Readable, well-labeled result sets are easier to understand, debug, share, and reason about.<br><br>

      - Taken together, these features shape a mindset where SQL is treated as a structured data conversation rather than a low-level command language.
      </span>

    </div>

  </div>

</template>

<!-- Mental focus: Which rows are allowed to exist? -->
<template> <!-- SQL: Filtering 1 -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
      <tr>
        <td>5</td><td>Paul</td><td>UK</td><td>London</td><td>2024-05-20</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <span class="C1">SELECT * FROM Customers WHERE Country = 'Mexico';</span><br>
        <span class="C2">SELECT * FROM Customers WHERE CustomerName LIKE 'L%';</span><br>
        <span class="C3">SELECT * FROM Customers WHERE City LIKE '_e%';</span><br>
        <span class="C4">SELECT * FROM Customers WHERE Country IN ('Germany', 'UK');</span><br>
        <span class="C5">SELECT * FROM Customers WHERE JoinDate BETWEEN '2024-01-01' AND '2024-03-31';</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- C1 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
    </table>

    <!-- C2 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
    </table>

    <!-- C3 Output (Corrected) -->
<table class="example" border="1" cellspacing="0" cellpadding="5">
  <tr class="C3">
    <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
  </tr>
  <tr>
    <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
  </tr>
  <tr>
    <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
  </tr>
</table>

    <!-- C4 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
      <tr>
        <td>5</td><td>Paul</td><td>UK</td><td>London</td><td>2024-05-20</td>
      </tr>
    </table>

    <!-- C5 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>WHERE Country = 'Mexico'</code></span> – Filters records <code>where</code> the Country column exactly matches 'Mexico'. <code>where</code> Select different regions of information to collect, like the column Country. <br>
      <span class="C2"><code>CustomerName LIKE 'L%'</code></span> – Filters names starting with 'L'. The % wildcard represents zero or more characters. so example %a% - ###a###, ##a##a## or #a#####, and %a - ###a <br>
      <span class="C3"><code>City LIKE '_e%'</code></span> – Filters cities where the second letter is 'e' and any number of characters follow. Combines _ (single character) and % (multiple characters).<br>
      <span class="C4"><code>Country IN ('Germany','UK')</code></span> – Filters rows where Country is any of the listed values. Equivalent to multiple OR conditions. So you can use identifiers like country or <code>-,+,/,*,</code>  <br>
      <span class="C5"><code>JoinDate BETWEEN '2024-01-01' AND '2024-03-31'</code></span> – Filters rows where JoinDate falls inclusively within the range. BETWEEN works with numbers, text (alphabetical range), and dates.<br><br>

      <strong>Notes:</strong><br>
      <span>
        - LIKE without wildcards behaves like exact match.<br>
        - always remember these extended patterns are database-specific and may not work in MySQL or PostgreSQL without using regular expressions.<br>
        - Extended wildcards: [], ^, -, {} exist in some SQL dialects.<br>
        - [] lets you match one single character from a specific list (e.g., [LM]% means the name must start with either L or M)<br>
        - ^ inside [] means any one character except those listed ([^L]% means the name cannot start with L)<br>
        - inside [] creates an alphabetical range ([A-C]% means the name starts with A, B, or C)<br>
        - {} (in some dialects) is used to escape special characters so symbols like % or _ are treated as normal text instead of wildcards;
      </span><br><br>

      <strong>Concept & Spirit:</strong><br>
      <span>
        - Learn to think in terms of **filters** and **patterns**.<br>
        - Break down conditions: exact match → pattern match → set inclusion → ranges.<br>
        - Use the right operator for the mental model: LIKE for flexible patterns, IN for discrete sets, BETWEEN for ranges.<br>
        - Layer your WHERE clauses incrementally to avoid mistakes.<br>
        - Beginner habit: always visualize the table when writing conditions.
      </span>
    </div>

  </div>

</template>

<!-- Mental focus: Which rows are allowed to exist? -->
<template> <!-- SQL: Filtering 2 -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
      <tr>
        <td>5</td><td>Paul</td><td>UK</td><td>London</td><td>2024-05-20</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <span class="C1">SELECT * FROM Customers WHERE Country = 'Mexico';</span><br>
        <span class="C2">SELECT * FROM Customers WHERE CustomerName LIKE 'L%';</span><br>
        <span class="C3">SELECT * FROM Customers WHERE City LIKE '_e%';</span><br>
        <span class="C4">SELECT * FROM Customers WHERE Country IN ('Germany', 'UK');</span><br>
        <span class="C5">SELECT * FROM Customers WHERE JoinDate BETWEEN '2024-01-01' AND '2024-03-31';</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- C1 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
    </table>

    <!-- C2 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
      </tr>
    </table>

    <!-- C3 Output (Corrected) -->
<table class="example" border="1" cellspacing="0" cellpadding="5">
  <tr class="C3">
    <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
  </tr>
  <tr>
    <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
  </tr>
  <tr>
    <td>4</td><td>Laura</td><td>Mexico</td><td>Leon</td><td>2024-04-01</td>
  </tr>
</table>

    <!-- C4 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
      <tr>
        <td>5</td><td>Paul</td><td>UK</td><td>London</td><td>2024-05-20</td>
      </tr>
    </table>

    <!-- C5 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th><th>City</th><th>JoinDate</th>
      </tr>
      <tr>
        <td>1</td><td>Alberto</td><td>Mexico</td><td>La Paz</td><td>2024-01-05</td>
      </tr>
      <tr>
        <td>2</td><td>Lars</td><td>Sweden</td><td>Stockholm</td><td>2024-02-10</td>
      </tr>
      <tr>
        <td>3</td><td>Maria</td><td>Germany</td><td>Berlin</td><td>2024-03-15</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>WHERE Country = 'Mexico'</code></span> – Filters records <code>where</code> the Country column exactly matches 'Mexico'. <code>where</code> Select different regions of information to collect, like the column Country. <br>
      <span class="C2"><code>CustomerName LIKE 'L%'</code></span> – Filters names starting with 'L'. The % wildcard represents zero or more characters. so example %a% - ###a###, ##a##a## or #a#####, and %a - ###a <br>
      <span class="C3"><code>City LIKE '_e%'</code></span> – Filters cities where the second letter is 'e' and any number of characters follow. Combines _ (single character) and % (multiple characters).<br>
      <span class="C4"><code>Country IN ('Germany','UK')</code></span> – Filters rows where Country is any of the listed values. Equivalent to multiple OR conditions. So you can use identifiers like country or <code>-,+,/,*,</code>  <br>
      <span class="C5"><code>JoinDate BETWEEN '2024-01-01' AND '2024-03-31'</code></span> – Filters rows where JoinDate falls inclusively within the range. BETWEEN works with numbers, text (alphabetical range), and dates.<br><br>

      <strong>Notes:</strong><br>
      <span>
        - LIKE without wildcards behaves like exact match.<br>
        - always remember these extended patterns are database-specific and may not work in MySQL or PostgreSQL without using regular expressions.<br>
        - Extended wildcards: [], ^, -, {} exist in some SQL dialects.<br>
        - [] lets you match one single character from a specific list (e.g., [LM]% means the name must start with either L or M)<br>
        - ^ inside [] means any one character except those listed ([^L]% means the name cannot start with L)<br>
        - inside [] creates an alphabetical range ([A-C]% means the name starts with A, B, or C)<br>
        - {} (in some dialects) is used to escape special characters so symbols like % or _ are treated as normal text instead of wildcards;
      </span><br><br>

      <strong>Concept & Spirit:</strong><br>
      <span>
        - Learn to think in terms of **filters** and **patterns**.<br>
        - Break down conditions: exact match → pattern match → set inclusion → ranges.<br>
        - Use the right operator for the mental model: LIKE for flexible patterns, IN for discrete sets, BETWEEN for ranges.<br>
        - Layer your WHERE clauses incrementally to avoid mistakes.<br>
        - Beginner habit: always visualize the table when writing conditions.
      </span>
    </div>

  </div>

</template>

<!-- Mental focus: How conditions interact with each other -->
<template> <!-- SQL: AND / OR / NOT -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Customers Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr>
        <td>1</td><td>Gabriel Garcia</td><td>Spain</td>
      </tr>
      <tr>
        <td>2</td><td>Robert King</td><td>Spain</td>
      </tr>
      <tr>
        <td>3</td><td>Maria Schmidt</td><td>Germany</td>
      </tr>
      <tr>
        <td>4</td><td>Giovanni Rossi</td><td>Italy</td>
      </tr>
      <tr>
        <td>5</td><td>Greta Müller</td><td>Germany</td>
      </tr>
      <tr>
        <td>6</td><td>Rafael Torres</td><td>Spain</td>
      </tr>
      <tr>
        <td>7</td><td>Anna Lopez</td><td>Spain</td>
      </tr>
      <tr>
        <td>8</td><td>George Brown</td><td>USA</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <!-- AND Example -->
        <span class="C1">SELECT * FROM Customers<br>
        WHERE Country = 'Spain' AND CustomerName LIKE 'G%';</span><br><br>

        <!-- OR Example -->
        <span class="C2">SELECT * FROM Customers<br>
        WHERE Country = 'Germany' OR Country = 'Spain';</span><br><br>

        <!-- AND + OR with Parentheses -->
        <span class="C3">SELECT * FROM Customers<br>
        WHERE Country = 'Spain' AND (CustomerName LIKE 'G%' OR CustomerName LIKE 'R%');</span><br><br>

        <!-- NOT Example -->
        <span class="C4">SELECT * FROM Customers<br>
        WHERE NOT Country = 'Spain';</span>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- C1 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr>
        <td>1</td><td>Gabriel Garcia</td><td>Spain</td>
      </tr>
    </table>
    <br>

    <!-- C2 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr>
        <td>1</td><td>Gabriel Garcia</td><td>Spain</td>
      </tr>
      <tr>
        <td>2</td><td>Robert King</td><td>Spain</td>
      </tr>
      <tr>
        <td>3</td><td>Maria Schmidt</td><td>Germany</td>
      </tr>
      <tr>
        <td>5</td><td>Greta Müller</td><td>Germany</td>
      </tr>
      <tr>
        <td>6</td><td>Rafael Torres</td><td>Spain</td>
      </tr>
      <tr>
        <td>7</td><td>Anna Lopez</td><td>Spain</td>
      </tr>
    </table>
    <br>

    <!-- C3 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr>
        <td>1</td><td>Gabriel Garcia</td><td>Spain</td>
      </tr>
      <tr>
        <td>2</td><td>Robert King</td><td>Spain</td>
      </tr>
      <tr>
        <td>6</td><td>Rafael Torres</td><td>Spain</td>
      </tr>
    </table>
    <br>

    <!-- C4 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr>
        <td>3</td><td>Maria Schmidt</td><td>Germany</td>
      </tr>
      <tr>
        <td>4</td><td>Giovanni Rossi</td><td>Italy</td>
      </tr>
      <tr>
        <td>5</td><td>Greta Müller</td><td>Germany</td>
      </tr>
      <tr>
        <td>8</td><td>George Brown</td><td>USA</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>AND</code></span>
      <span>
        – Think of <b>AND</b> like saying: “This AND that must both be true.”  
        The row is returned only if <b>every condition</b> is TRUE.  
        In our example, the customer must be from Spain <i>and</i> their name must start with “G”.  
        If one part fails, the entire condition fails.
      </span><br><br>

      <span class="C2"><code>OR</code></span>
      <span>
        – Think of <b>OR</b> like saying: “Either this OR that is fine.”  
        Only <b>one condition</b> needs to be TRUE for the row to appear.  
        If the customer is from Germany OR Spain, they will be included.
      </span><br><br>

      <span class="C3"><code>( ) Parentheses</code></span>
      <span>
        – Parentheses control logic order, just like in math.  
        SQL evaluates <b>AND before OR</b> by default.  
        So we use parentheses to make sure the database checks the grouped conditions first.  
        Without parentheses, SQL might return unintended results.
      </span><br><br>

      <span class="C4"><code>NOT</code></span>
      <span>
        – <b>NOT</b> reverses a condition.  
        It gives the opposite result.  
        If a condition says “Country = Spain”, adding NOT means  
        “Country is NOT Spain.”
      </span><br><br>

      <!-- NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - Logical operators are heavily used in real applications when filtering search results or user data.
      </span><br><br>

      <!-- CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - These operators teach logical thinking in databases.<br>
        - Writing SQL is like asking very precise questions to your data.<br>
        - The goal is clarity: always write conditions in a way that another developer immediately understands your intent.<br>
        - Parentheses are not just syntax — they protect your logic from mistakes.<br>
        - Think in terms of truth values: each condition is either TRUE or FALSE.
      </span>

    </div>

  </div>

</template>

<!-- Mental focus: In what order do I want to see the data? -->
<template> <!-- SQL: ORDER BY, ASC, and DESC -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Products Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ProductID</th><th>ProductName</th><th>Price</th><th>Country</th>
      </tr>
      <tr>
        <td>1</td><td>Apple Juice</td><td>3.50</td><td>USA</td>
      </tr>
      <tr>
        <td>2</td><td>Banana Milk</td><td>2.00</td><td>Sweden</td>
      </tr>
      <tr>
        <td>3</td><td>Carrot Cake</td><td>5.00</td><td>USA</td>
      </tr>
      <tr>
        <td>4</td><td>Avocado Oil</td><td>8.00</td><td>Mexico</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>

        <!-- C1: Basic ORDER BY -->
        <span class="C1">SELECT * FROM Products<br>
        ORDER BY Price;</span><br><br>

        <!-- C2: DESC -->
        <span class="C2">SELECT * FROM Products<br>
        ORDER BY Price DESC;</span><br><br>

        <!-- C3: Alphabetical -->
        <span class="C3">SELECT * FROM Products<br>
        ORDER BY ProductName;</span><br><br>

        <!-- C4: Alphabetical DESC -->
        <span class="C4">SELECT * FROM Products<br>
        ORDER BY ProductName DESC;</span><br><br>

        <!-- C5: Multiple Columns -->
        <span class="C5">SELECT * FROM Products<br>
        ORDER BY Country, ProductName;</span><br><br>

        <!-- C6: Mixed ASC / DESC -->
        <span class="C6">SELECT * FROM Products<br>
        ORDER BY Country ASC, ProductName DESC;</span>

      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output (C1 – ORDER BY Price ASC):</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>ProductID</th><th>ProductName</th><th>Price</th><th>Country</th>
      </tr>
      <tr>
        <td>2</td><td>Banana Milk</td><td>2.00</td><td>Sweden</td>
      </tr>
      <tr>
        <td>1</td><td>Apple Juice</td><td>3.50</td><td>USA</td>
      </tr>
      <tr>
        <td>3</td><td>Carrot Cake</td><td>5.00</td><td>USA</td>
      </tr>
      <tr>
        <td>4</td><td>Avocado Oil</td><td>8.00</td><td>Mexico</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>ORDER BY Price</code></span>
      <span> – Sorts the results by Price in ascending order by default (smallest → largest). Think of it like sorting numbers from lowest to highest.</span><br>

      <span class="C2"><code>DESC</code></span>
      <span> – Reverses the order (largest → smallest). If you don’t write ASC or DESC, SQL assumes ASC automatically.</span><br>

      <span class="C3"><code>ORDER BY ProductName</code></span>
      <span> – When sorting text (strings), SQL sorts alphabetically (A → Z). Just like a dictionary.</span><br>

      <span class="C4"><code>ProductName DESC</code></span>
      <span> – Reverse alphabetical order (Z → A).</span><br>

      <span class="C5"><code>ORDER BY Country, ProductName</code></span>
      <span> – First sorts by Country. If multiple rows have the same Country, then it sorts those rows by ProductName. Think of it as: primary sort → secondary sort.</span><br>

      <span class="C6"><code>Country ASC, ProductName DESC</code></span>
      <span> – You can mix directions. Here: Countries A → Z, but inside each country, names are Z → A.</span><br><br>

      <!-- NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - ASC is optional because it is the default.<br>
        - ORDER BY always comes after FROM (and after WHERE if used).<br>
        - Sorting can affect performance on very large tables.<br>
        - You can sort by columns not shown in SELECT (depending on SQL dialect).<br>
        - Alphabetical sorting depends on database collation (case sensitivity rules).
      </span><br><br>

      <!-- CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - ORDER BY teaches structured thinking about how data should be presented.<br>
        - Databases store data efficiently, but presentation order is your responsibility.<br>
        - Sorting is about clarity: making results meaningful for humans.<br>
        - Multiple column sorting teaches priority logic (primary key vs secondary key thinking).
      </span>

    </div>

  </div>

</template>

<!-- 3. Nulls & Conditional Logic -->
<template> <!-- SQL: Nulls & Conditional Logic -->

  <div class="bubble">
    
    <!-- 0. TABLE EXAMPLES -->
    <h3>Example: Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerName</th><th>ContactName</th><th>Address</th>
      </tr>
      <tr>
        <td>Maria Anders</td><td>Maria A.</td><td>Berlin</td>
      </tr>
      <tr>
        <td>John Doe</td><td>John D.</td><td></td>
      </tr>
      <tr>
        <td>Linda Smith</td><td>Linda S.</td><td>New York</td>
      </tr>
    </table>


    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <!-- IS NULL example -->
        <span class="C1">SELECT CustomerName, ContactName, Address<br>
        &nbsp;&nbsp;FROM Customers<br>
        &nbsp;&nbsp;WHERE Address IS NULL;</span><br><br>

        <!-- IS NOT NULL example -->
        <span class="C2">SELECT CustomerName, ContactName, Address<br>
        &nbsp;&nbsp;FROM Customers<br>
        &nbsp;&nbsp;WHERE Address IS NOT NULL;</span><br><br>

        <!-- NULL Function example -->
        <span class="C3">SELECT CustomerName, ContactName, IFNULL(Address, 'No Address') AS Address<br>
        &nbsp;&nbsp;FROM Customers;</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Outputs:</h3>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>CustomerName</th><th>ContactName</th><th>Address</th>
      </tr>
      <tr>
        <td>John Doe</td><td>John D.</td><td></td>
      </tr>
    </table>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>CustomerName</th><th>ContactName</th><th>Address</th>
      </tr>
      <tr>
        <td>Maria Anders</td><td>Maria A.</td><td>Berlin</td>
      </tr>
      <tr>
        <td>Linda Smith</td><td>Linda S.</td><td>New York</td>
      </tr>
    </table>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>CustomerName</th><th>ContactName</th><th>Address</th>
      </tr>
      <tr>
        <td>Maria Anders</td><td>Maria A.</td><td>Berlin</td>
      </tr>
      <tr>
        <td>John Doe</td><td>John D.</td><td>No Address</td>
      </tr>
      <tr>
        <td>Linda Smith</td><td>Linda S.</td><td>New York</td>
      </tr>
    </table>

    <!-- 3. EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>IS NULL</code></span><span> – Checks for fields that are empty or have a no value. Never use = NULL; always use IS NULL to correctly identify unknown values.</span><br>
      <span class="C2"><code>IS NOT NULL</code></span><span> – Checks for fields that contain all value (none can be empty). Useful for filtering out incomplete records.</span><br>
      <span class="C3"><code>IFNULL(Address, 'No Address')</code></span><span> – Replaces NULL values with a default, ensuring calculations or display logic don’t break. For SQL Server, use ISNULL(); for PostgreSQL/standard SQL, use COALESCE().</span><br><br>

      <!-- Notes -->
      <strong>Notes:</strong><br>
      <span>
        - NULL is different from zero or empty string – it represents unknown or missing data.<br>
        - Always use IS NULL / IS NOT NULL for testing NULLs; = or <> will not work.<br>
        - Using NULL functions helps avoid errors in aggregates like SUM() or AVG().
      </span><br><br>

      <!-- Concept & Spirit -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - Think of NULL as “unknown” rather than empty – it’s a signal that data is missing.<br>
        - Using IS NULL / IS NOT NULL teaches careful data validation and safety in queries.<br>
        - NULL replacement functions encourage defensive coding: you plan for missing data, ensuring reliable results and cleaner outputs.<br>
        - Big-picture: handling NULLs properly keeps your database queries accurate, predictable, and beginner-friendly.
      </span>
    </div>

  </div> 
</template>

<template> <!-- SQL: CASE -->
  <div class="bubble">
    
    <!-- 0. TABLE EXAMPLE -->
    <h3>Example: Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>OrderID</th><th>Quantity</th>
      </tr>
      <tr>
        <td>101</td><td>45</td>
      </tr>
      <tr>
        <td>102</td><td>30</td>
      </tr>
      <tr>
        <td>103</td><td>10</td>
      </tr>
      <tr>
        <td>104</td><td>25</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <!-- Example 1: CASE with ELSE -->
        SELECT OrderID, Quantity,<br>
        &nbsp;&nbsp;<span class="C1">CASE</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="C2">WHEN Quantity > 30 THEN 'Greater than 30'</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="C2">WHEN Quantity = 30 THEN 'Equals 30'</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="C3">ELSE 'Under 30'</span><br>
        &nbsp;&nbsp;<span class="C1">END AS OverUnderNull</span><br>
        FROM OrderDetails;<br><br>

        <!-- Example 2: CASE without ELSE -->
        SELECT OrderID, Quantity,<br>
        &nbsp;&nbsp;<span class="C1">CASE</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="C2">WHEN Quantity > 50 THEN 'Over 50'</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="C2">WHEN Quantity = 45 THEN 'Exactly 45'</span><br>
        &nbsp;&nbsp;<span class="C1">END AS OverUnderNull</span><br>
        FROM OrderDetails;
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>OrderID</th><th>Quantity</th><th>OverUnderNull</th>
      </tr>
      <tr>
        <td>101</td><td>45</td><td>Greater than 30</td>
      </tr>
      <tr>
        <td>102</td><td>30</td><td>Equals 30</td>
      </tr>
      <tr>
        <td>103</td><td>10</td><td>Under 30</td>
      </tr>
      <tr>
        <td>104</td><td>25</td><td>Under 30</td>
      </tr>
    </table>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>OrderID</th><th>Quantity</th><th>OverUnderNull</th>
      </tr>
      <tr>
        <td>101</td><td>45</td><td>Over 40</td>
      </tr>
      <tr>
        <td>102</td><td>30</td><td>Exactly 30</td>
      </tr>
      <tr>
        <td>103</td><td>10</td><td>NULL</td>
      </tr>
      <tr>
        <td>104</td><td>25</td><td>NULL</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>CASE ... END AS #####;</code></span><span> Wraps the entire conditional expression; CASE starts it, END closes it. AS ##### says what that new column's going to be called like OverUnderNull</span><br><br>
      <span class="C2"><code>WHEN condition THEN result;</code></span><span> Checks a condition; the first true one returns its result and stops further checks. So for instance, if nothing is greater than 30, only then do we go to the next condition state.</span><br><br>
      <span class="C3"><code>ELSE result;</code></span><span> Optional default value if none of the WHEN conditions match. If omitted, returns NULL for those conditions that were not met in the WHEN cases.</span><br><br>

      <!-- 3.2 NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - CASE can be used in SELECT, WHERE, ORDER BY, and UPDATE statements.<br>
        - Multiple CASE statements can appear in a single query.<br>
      </span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - Teaches conditional thinking in SQL, similar to if-else in programming.<br>
        - Embeds logic in queries for readability and maintainability.<br>
        - Encourages planning the order of conditions carefully and handling defaults explicitly.
      </span>
    </div>


  </div>
</template>

<template> <!-- SQL: EXISTS, ANY, ALL -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>SupplierID</th><th>SupplierName</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr>
        <td>1</td><td>Supplier A</td><td>Widget</td><td>15</td>
      </tr>
      <tr>
        <td>2</td><td>Supplier B</td><td>Gadget</td><td>25</td>
      </tr>
      <tr>
        <td>3</td><td>Supplier C</td><td>Doohickey</td><td>10</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <!-- EXISTS Example -->
        SELECT SupplierName FROM Suppliers<br>
        &nbsp;&nbsp;WHERE <span class="C1">EXISTS (SELECT ProductName FROM Products<br>
        &nbsp;&nbsp;&nbsp;&nbsp;WHERE Products.SupplierID = Suppliers.SupplierID AND Price &lt; 20);</span><br><br>

        <!-- ANY Example -->
        SELECT ProductName FROM Products<br>
        &nbsp;&nbsp;WHERE ProductID <span class="C2">= ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);</span><br><br>

        <!-- ALL Example -->
        SELECT ProductName FROM Products<br>
        &nbsp;&nbsp;WHERE ProductID <span class="C3">= ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);</span>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>SupplierName</th>
      </tr>
      <tr>
        <td>Supplier A</td>
      </tr>
      <tr>
        <td>Supplier C</td>
      </tr>
    </table>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>ProductName</th>
      </tr>
      <tr>
        <td>Widget</td>
      </tr>
      <tr>
        <td>Doohickey</td>
      </tr>
    </table>

    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>ProductName</th>
      </tr>
      <tr>
        <td>(no rows returned)</td>
      </tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>EXISTS</code></span><span> – Checks if at least one row in the subquery meets the condition. Returns TRUE/FALSE. Useful for yes/no checks without returning data from subquery.</span><br><br>
      <span class="C2"><code>ANY</code></span><span> – Compares a value to any value returned by a subquery. Returns TRUE if the comparison is true for at least one value. Works with standard comparison operators (=, &lt;&gt;, !=, &gt;, &gt;=, &lt;, &lt;=).</span><br><br>
      <span class="C3"><code>ALL</code></span><span> – Compares a value to all values returned by a subquery. Returns TRUE only if the comparison is true for every value. Also uses standard comparison operators.</span><br><br>

      <!-- 3.2 NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - EXISTS is more efficient for large datasets when you only care about presence, not data.<br>
        - ANY is like an OR across the subquery results; ALL is like an AND.<br>
        - Use ALL carefully; if even one row doesn’t match, the condition is FALSE.<br>
        - EXISTS often replaces IN for performance in some SQL engines.
      </span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        - Think of EXISTS as asking a yes/no question: "Does at least one row meet this criteria?"<br>
        - ANY and ALL teach how to reason about comparisons over ranges of values rather than single values.<br>
        - These operators help write expressive, declarative queries without looping manually over rows.<br>
        - Mastering them builds skill in thinking in set-based logic, a core SQL mindset.
      </span>
    </div>

  </div>

</template>

<!-- 4. Aggregation & Grouping -->
<template> <!-- SQL: MIN(), MAX(), COUNT(), SUM(), AVG()-->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE -->
    <h3>Example: Products Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ProductID</th><th>ProductName</th><th>Price</th><th>CategoryID</th>
      </tr>
      <tr>
        <td>1</td><td>Keyboard</td><td>50</td><td>1</td>
      </tr>
      <tr>
        <td>2</td><td>Mouse</td><td>25</td><td>1</td>
      </tr>
      <tr>
        <td>3</td><td>Monitor</td><td>200</td><td>2</td>
      </tr>
      <tr>
        <td>4</td><td>USB Cable</td><td>10</td><td>1</td>
      </tr>
      <tr>
        <td>5</td><td>Webcam</td><td>80</td><td>2</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>

        <!-- MIN -->
        <span class="C1">SELECT MIN(Price) AS LowestPrice</span><br>
        &nbsp;&nbsp;<span class="C1">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C1">WHERE CategoryID = 1;</span><br><br>

        <!-- MAX -->
        <span class="C2">SELECT MAX(Price) AS HighestPrice</span><br>
        &nbsp;&nbsp;<span class="C2">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C2">WHERE CategoryID = 1;</span><br><br>

        <!-- COUNT -->
        <span class="C3">SELECT COUNT(*) AS TotalProducts</span><br>
        &nbsp;&nbsp;<span class="C3">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C3">WHERE Price &gt; 20;</span><br><br>

        <!-- SUM -->
        <span class="C4">SELECT SUM(Price) AS TotalCategoryOne</span><br>
        &nbsp;&nbsp;<span class="C4">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C4">WHERE CategoryID = 1;</span><br><br>

        <!-- AVG -->
        <span class="C5">SELECT AVG(Price) AS AverageCategoryOne</span><br>
        &nbsp;&nbsp;<span class="C5">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C5">WHERE CategoryID = 1;</span><br><br>

        <!-- GROUP BY Preview -->
        <span class="C6">SELECT CategoryID, SUM(Price) AS TotalPerCategory</span><br>
        &nbsp;&nbsp;<span class="C6">FROM Products</span><br>
        &nbsp;&nbsp;<span class="C6">GROUP BY CategoryID;</span>

      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->

    <h3>Example Output:</h3>

    <!-- MIN -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>LowestPrice</th>
      </tr>
      <tr>
        <td>10</td>
      </tr>
    </table>

    <!-- MAX -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>HighestPrice</th>
      </tr>
      <tr>
        <td>50</td>
      </tr>
    </table>

    <!-- COUNT -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>TotalProducts</th>
      </tr>
      <tr>
        <td>4</td>
      </tr>
    </table>

    <!-- SUM -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>TotalCategoryOne</th>
      </tr>
      <tr>
        <td>85</td>
      </tr>
    </table>

    <!-- AVG -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5">
        <th>AverageCategoryOne</th>
      </tr>
      <tr>
        <td>28.33</td>
      </tr>
    </table>

    <!-- GROUP BY Preview -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C6">
        <th>CategoryID</th><th>TotalPerCategory</th>
      </tr>
      <tr>
        <td>1</td><td>85</td>
      </tr>
      <tr>
        <td>2</td><td>280</td>
      </tr>
    </table>

    <!-- 3. EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span>
        SQL Aggregate Functions perform a calculation on multiple rows and return a single value.
        Without GROUP BY, all filtered rows are treated as one big group.
      </span><br><br>

      <span class="C1"><code>MIN()</code></span>
      <span> – Finds the smallest value in the filtered set.</span><br>

      <span class="C2"><code>MAX()</code></span>
      <span> – Finds the largest value in the filtered set.</span><br>

      <span class="C3"><code>COUNT()</code></span>
      <span> – Counts how many rows match the condition.</span><br>

      <span class="C4"><code>SUM()</code></span>
      <span> – Adds together all values from the filtered rows.</span><br>

      <span class="C5"><code>AVG()</code></span>
      <span> – Calculates the average value of the filtered rows.</span><br>

      <span class="C6"><code>GROUP BY</code></span>
      <span> – Instead of treating all rows as one group, SQL splits them by CategoryID.
      The aggregate function is then calculated separately for each category.
      This produces multiple rows instead of one.</span><br><br>

      <strong>Notes:</strong><br>
      <span>
        - Aggregate functions ignore NULL values (except COUNT(*)).<br>
        - WHERE filters rows before aggregation happens.<br>
        - Without GROUP BY → one result row.<br>
        - With GROUP BY → one result per group.<br>
        - GROUP BY will be fully explained in the next template.<br>
        - MIN(), MAX(), COUNT(), SUM(), AVG() are function names — they must always be followed by parentheses.<br>
        - The value inside the parentheses tells SQL what to calculate on.<br>
        - Example: SUM(Price) means "add all values from the Price column".<br>
        - You cannot leave the parentheses empty — SQL needs to know what column or expression to use.<br>
        - COUNT(*) is different: the * tells SQL to count all rows, not a specific column.
      </span><br><br>

      <strong>Concept & Spirit:</strong><br>
      <span>
        Aggregates teach you to summarize data instead of reading row by row.
        GROUP BY extends that idea by letting you summarize per category.
        This is where SQL becomes powerful: you describe the result you want,
        and the database handles the calculation.
      </span>

    </div>

  </div>

</template>

<template> <!-- SQL: ORDER BY -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Products Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr>
        <td>1</td><td>Laptop</td><td>1200</td>
      </tr>
      <tr>
        <td>2</td><td>Mouse</td><td>25</td>
      </tr>
      <tr>
        <td>3</td><td>Keyboard</td><td>75</td>
      </tr>
      <tr>
        <td>4</td><td>Monitor</td><td>300</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>

        <span class="C1">SELECT * FROM Products ORDER BY Price;</span><br><br>

        <span class="C2">SELECT * FROM Products ORDER BY Price DESC;</span><br><br>

        <span class="C3">SELECT * FROM Products ORDER BY ProductName;</span><br><br>

        <span class="C4">SELECT * FROM Products ORDER BY ProductName DESC;</span><br><br>

        <span class="C5">SELECT * FROM Products ORDER BY Price ASC, ProductName DESC;</span>

      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->

    <!-- C1 -->
    <h3>Example Output:</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr><td>2</td><td>Mouse</td><td>25</td></tr>
      <tr><td>3</td><td>Keyboard</td><td>75</td></tr>
      <tr><td>4</td><td>Monitor</td><td>300</td></tr>
      <tr><td>1</td><td>Laptop</td><td>1200</td></tr>
    </table>

    <!-- C2 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr><td>1</td><td>Laptop</td><td>1200</td></tr>
      <tr><td>4</td><td>Monitor</td><td>300</td></tr>
      <tr><td>3</td><td>Keyboard</td><td>75</td></tr>
      <tr><td>2</td><td>Mouse</td><td>25</td></tr>
    </table>

    <!-- C3 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr><td>3</td><td>Keyboard</td><td>75</td></tr>
      <tr><td>1</td><td>Laptop</td><td>1200</td></tr>
      <tr><td>4</td><td>Monitor</td><td>300</td></tr>
      <tr><td>2</td><td>Mouse</td><td>25</td></tr>
    </table>

    <!-- C4 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4">
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr><td>2</td><td>Mouse</td><td>25</td></tr>
      <tr><td>4</td><td>Monitor</td><td>300</td></tr>
      <tr><td>1</td><td>Laptop</td><td>1200</td></tr>
      <tr><td>3</td><td>Keyboard</td><td>75</td></tr>
    </table>

    <!-- C5 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5">
        <th>ProductID</th><th>ProductName</th><th>Price</th>
      </tr>
      <tr><td>2</td><td>Mouse</td><td>25</td></tr>
      <tr><td>3</td><td>Keyboard</td><td>75</td></tr>
      <tr><td>4</td><td>Monitor</td><td>300</td></tr>
      <tr><td>1</td><td>Laptop</td><td>1200</td></tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>ORDER BY Price</code></span>
      <span>– Sorts results by <code>Price</code> in ascending order (lowest → highest). 
      Ascending is the default, so we don’t need to write <code>ASC</code>.</span><br>

      <span class="C2"><code>ORDER BY Price DESC</code></span>
      <span>– Reverses the order. Instead of smallest first, it shows largest first.
      Think of it as flipping the list upside down.</span><br>

      <span class="C3"><code>ORDER BY ProductName</code></span>
      <span>– When sorting text, SQL orders alphabetically (A → Z).</span><br>

      <span class="C4"><code>ORDER BY ProductName DESC</code></span>
      <span>– Reverse alphabetical order (Z → A).</span><br>

      <span class="C5"><code>ORDER BY Price ASC, ProductName DESC</code></span>
      <span>– SQL sorts by the first column first. If two rows have the same 
      <code>Price</code>, it then sorts those rows by <code>ProductName</code>.
      Think of it like sorting papers: first by grade, then by name if grades match.</span><br><br>

      <!-- NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - <code>ASC</code> is optional because ascending is default.<br>
        - ORDER BY always comes after WHERE (if used).<br>
        - You can sort by columns that are not shown in SELECT (in most SQL systems).<br>
        - Sorting does NOT change the table permanently — it only changes how results are displayed.
      </span><br><br>

      <!-- CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        Why didn’t we put this in the template earlier about select information?<br>

        The first templates focused on retrieving data (SELECT and WHERE).
        That teaches: <em>“Which rows do I want?”</em><br>

        ORDER BY teaches something different:
        <em>“In what order should I see them?”</em><br>

        Filtering (WHERE) decides WHAT data appears.<br>
        Sorting (ORDER BY) decides HOW it is organized.<br>

        We separate them because they teach two different mental models:
        - Selection logic (filtering)
        - Presentation logic (ordering)<br>

        Big beginner lesson:
        First think about getting the correct data.
        Then think about how you want it arranged.
      </span>

    </div>

  </div>

</template>

<template> <!-- SQL: HAVING -->
  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Customers Table Preview</h3>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerID</th><th>CustomerName</th><th>Country</th>
      </tr>
      <tr><td>1</td><td>Anna</td><td>Germany</td></tr>
      <tr><td>2</td><td>John</td><td>Germany</td></tr>
      <tr><td>3</td><td>Maria</td><td>Brazil</td></tr>
      <tr><td>4</td><td>James</td><td>Brazil</td></tr>
      <tr><td>5</td><td>David</td><td>Brazil</td></tr>
      <tr><td>6</td><td>Sophia</td><td>Germany</td></tr>
      <tr><td>7</td><td>Lucas</td><td>Germany</td></tr>
      <tr><td>8</td><td>Emma</td><td>Germany</td></tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>

        SELECT Country, COUNT(CustomerID)<br>
        FROM Customers<br>
        GROUP BY Country<br>
        <span class="C1">HAVING COUNT(CustomerID) > 3;</span><br><br>

        SELECT Country, COUNT(CustomerID)<br>
        FROM Customers<br>
        <span class="C2">WHERE Country != 'Brazil'</span><br>
        GROUP BY Country<br>
        <span class="C2">HAVING COUNT(CustomerID) > 3;</span><br><br>

        
        SELECT Country, COUNT(CustomerID)<br>
        FROM Customers<br>
        GROUP BY Country<br>
        <span class="C3">HAVING COUNT(CustomerID) > 1<br>
        ORDER BY COUNT(CustomerID) DESC;</span>
        

      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- C1 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1">
        <th>Country</th><th>COUNT(CustomerID)</th>
      </tr>
      <tr><td>Germany</td><td>5</td></tr>
      <tr><td>Brazil</td><td>3</td></tr>
    </table>

    <!-- C2 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2">
        <th>Country</th><th>COUNT(CustomerID)</th>
      </tr>
      <tr><td>Germany</td><td>5</td></tr>
    </table>

    <!-- C3 -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3">
        <th>Country</th><th>COUNT(CustomerID)</th>
      </tr>
      <tr><td>Germany</td><td>5</td></tr>
      <tr><td>Brazil</td><td>3</td></tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>HAVING COUNT(CustomerID) &gt; 3</code></span>
      <span>
      – After grouping customers by <code>Country</code>, HAVING filters the grouped results.
      We are no longer filtering individual rows — we are filtering entire groups.
      </span><br>

      <span class="C2"><code>WHERE Country != 'Brazil'</code></span>
      <span>
      – WHERE filters rows before grouping happens.
      Brazil rows are removed first.
      Then GROUP BY runs.
      Then HAVING filters the grouped result.
      </span><br>

      <span class="C3"><code>ORDER BY COUNT(CustomerID) DESC</code></span>
      <span>
      – HAVING decides which groups stay.
      ORDER BY decides how the final result is arranged.
      Sorting does not change the data — only the presentation.
      </span><br><br>

      <!-- NOTES -->
      <strong>Notes:</strong><br>
      <span>
        - WHERE cannot use aggregate functions like <code>COUNT()</code>.<br>
        - HAVING was added to SQL specifically to filter aggregated results.<br>
        - Clause order matters: FROM → WHERE → GROUP BY → HAVING → ORDER BY.<br>
        - If you try <code>WHERE COUNT(CustomerID) &gt; 3</code>, SQL will throw an error.
      </span><br><br>

      <!-- CONCEPT & SPIRIT -->
      <strong>Concept & Spirit:</strong><br>
      <span>
        Why is HAVING its own? HAVING now teaches: “How do I filter calculated categories?” This is a different mental step. WHERE filters raw rows. GROUP BY filters a group from the rows. HAVING filters summarized groups. <br>

        Big beginner lesson:<br>
        1. Filter rows (WHERE)<br>
        2. Group rows (GROUP BY)<br>
        3. Filter groups (HAVING)<br>
        4. Sort results (ORDER BY)<br>
        SQL works in stages. Understanding those stages is more important than memorizing syntax.

      </span>

    </div>
    
  </div>
</template>

<!-- 5. Combining Tables -->

<template> <!-- SQL: JOIN/INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN, and SELF JOIN   -->
  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Tables Preview</h3>

    <h4>Customers Table</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>CustomerID</th><th>CustomerName</th><th>City</th>
      </tr>
      <tr>
        <td>1</td><td>Maria Anders</td><td>Berlin</td>
      </tr>
      <tr>
        <td>2</td><td>Francisco Chang</td><td>Madrid</td>
      </tr>
      <tr>
        <td>3</td><td>Roland Mendel</td><td>Berlin</td>
      </tr>
      <tr>
        <td>4</td><td>Helen Bennett</td><td>London</td>
      </tr>
    </table>

    <h4>Orders Table</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>OrderID</th><th>CustomerID</th><th>OrderDate</th>
      </tr>
      <tr>
        <td>101</td><td>1</td><td>2026-01-10</td>
      </tr>
      <tr>
        <td>102</td><td>3</td><td>2026-01-12</td>
      </tr>
      <tr>
        <td>103</td><td>5</td><td>2026-01-15</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>
        <!-- C1 – INNER JOIN -->
        SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate<br>
        FROM Customers<br>
        <span class="C1">
        INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;</span><br><br>

        <!-- C2 – LEFT JOIN -->
        SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate<br>
        FROM Customers<br>
        <span class="C2">LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID</span><br>
        ORDER BY Customers.CustomerName;<br><br>

        <!-- C3 – RIGHT JOIN -->
        SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate<br>
        FROM Customers<br>
        <span class="C3">RIGHT JOIN Orders ON Customers.CustomerID = Orders.CustomerID</span><br>
        ORDER BY Orders.OrderID;<br><br>

        <!-- C4 – FULL OUTER JOIN -->
        SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate<br>
        FROM Customers<br>
        <span class="C4">FULL OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID</span><br>
        ORDER BY Customers.CustomerName;<br><br>

        <!-- C5 – SELF JOIN -->
        SELECT A.CustomerName AS Customer1, B.CustomerName AS Customer2, A.City<br>
        <span class="C5">FROM Customers A, Customers B<br>
        WHERE A.CustomerID &lt;&gt; B.CustomerID AND A.City = B.City</span><br>
        ORDER BY A.City;
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <h4>INNER JOIN</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1"><th>CustomerName</th><th>OrderID</th><th>OrderDate</th></tr>
      <tr><td>Maria Anders</td><td>101</td><td>2026-01-10</td></tr>
      <tr><td>Roland Mendel</td><td>102</td><td>2026-01-12</td></tr>
    </table>

    <h4>LEFT JOIN</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2"><th>CustomerName</th><th>OrderID</th><th>OrderDate</th></tr>
      <tr><td>Francisco Chang</td><td>NULL</td><td>NULL</td></tr>
      <tr><td>Helen Bennett</td><td>NULL</td><td>NULL</td></tr>
      <tr><td>Maria Anders</td><td>101</td><td>2026-01-10</td></tr>
      <tr><td>Roland Mendel</td><td>102</td><td>2026-01-12</td></tr>
    </table>

    <h4>RIGHT JOIN</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3"><th>CustomerName</th><th>OrderID</th><th>OrderDate</th></tr>
      <tr><td>Maria Anders</td><td>101</td><td>2026-01-10</td></tr>
      <tr><td>Roland Mendel</td><td>102</td><td>2026-01-12</td></tr>
      <tr><td>NULL</td><td>103</td><td>2026-01-15</td></tr>
    </table>

    <h4>FULL OUTER JOIN</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4"><th>CustomerName</th><th>OrderID</th><th>OrderDate</th></tr>
      <tr><td>Francisco Chang</td><td>NULL</td><td>NULL</td></tr>
      <tr><td>Helen Bennett</td><td>NULL</td><td>NULL</td></tr>
      <tr><td>Maria Anders</td><td>101</td><td>2026-01-10</td></tr>
      <tr><td>Roland Mendel</td><td>102</td><td>2026-01-12</td></tr>
      <tr><td>NULL</td><td>103</td><td>2026-01-15</td></tr>
    </table>

    <h4>SELF JOIN</h4>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C5"><th>Customer1</th><th>Customer2</th><th>City</th></tr>
      <tr><td>Maria Anders</td><td>Roland Mendel</td><td>Berlin</td></tr>
      <tr><td>Roland Mendel</td><td>Maria Anders</td><td>Berlin</td></tr>
    </table>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span>With ON, it looks for a column of data that Is similar or the same data and JOIN depending on which one will join the data if they're the same</span><br>
      <span class="C1"><code>INNER JOIN</code></span><span> – Returns only the rows where there’s a match in both tables. Rows without matches are ignored.</span><br>
      <span class="C2"><code>LEFT JOIN</code></span><span> – Returns all rows from the left table; unmatched rows in the right table appear as NULL.</span><br>
      <span class="C3"><code>RIGHT JOIN</code></span><span> – Returns all rows from the right table; unmatched rows in the left table appear as NULL.</span><br>
      <span class="C4"><code>FULL OUTER JOIN</code></span><span> – Returns all rows from both tables; unmatched rows appear as NULL where there’s no match.</span><br>
      <span class="C5"><code>SELF JOIN</code></span><span> – Joins a table to itself; useful for finding relationships within the same table (e.g., customers in the same city).<br>
      Where is the SELF JOIN? I don’t see the word JOIN anywhere.”<br>
      That’s because this is the old (implicit) way of writing a self join.</span><br>
      SELF JOIN = FROM Customers A, Customers B<br>
      ON = WHERE A.CustomerID <> B.CustomerID AND A.City = B.City<br><br>

      <strong>Notes:</strong><br>
      <span>
        - SQL creates a temporary combined result. That result is returned to you. Then it disappears.
        - Always specify table names when column names exist in multiple tables.<br>
        - JOIN defaults to INNER JOIN.<br>
        - Use aliases (A, B) for clarity in SELF JOINs.<br>
        - LEFT/RIGHT/FULL JOIN help handle missing relationships elegantly.
      </span><br><br>

      <strong>Concept & Spirit:</strong><br>
      <span>
        - Joins teach how relational databases combine related data across tables.<br>
        - Understand the difference between "all rows" vs "matched rows".<br>
        - Thinking in sets: each JOIN type answers a different question about relationships between tables.<br>
        - Builds the mindset of designing queries that reflect real-world data connections.
      </span>
    </div>

  </div>
</template>

<template> <!-- SQL: UNION & UNION ALL -->

  <div class="bubble">

    <!-- 0. TABLE EXAMPLE (Existing Data) -->
    <h3>Example: Table Preview</h3>

    <!-- Customers Table -->
    <strong>Customers</strong>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ContactName</th><th>City</th><th>Country</th>
      </tr>
      <tr>
        <td>Maria Anders</td><td>Berlin</td><td>Germany</td>
      </tr>
      <tr>
        <td>Ana Trujillo</td><td>Madrid</td><td>Spain</td>
      </tr>
      <tr>
        <td>Thomas Hardy</td><td>Berlin</td><td>Germany</td>
      </tr>
    </table>

    <br>

    <!-- Suppliers Table -->
    <strong>Suppliers</strong>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ContactName</th><th>City</th><th>Country</th>
      </tr>
      <tr>
        <td>Heli Süßwaren</td><td>Berlin</td><td>Germany</td>
      </tr>
      <tr>
        <td>Nordic Foods</td><td>Hamburg</td><td>Germany</td>
      </tr>
      <tr>
        <td>New Orleans Cajun</td><td>New Orleans</td><td>USA</td>
      </tr>
    </table>

    <br>

    <!-- Employees Table (for C3 example) -->
    <strong>Employees</strong>
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>ContactName</th><th>City</th><th>Country</th>
      </tr>
      <tr>
        <td>John Smith</td><td>Berlin</td><td>Germany</td>
      </tr>
      <tr>
        <td>Sara Connor</td><td>London</td><td>UK</td>
      </tr>
    </table>

    <!-- 1. SQL CODE -->
    <h3>SQL Code:</h3>
    <div class="code_block">
      <code>

        <!-- C1 UNION -->
        <span class="C1">SELECT City FROM Customers<br>
        UNION<br>
        SELECT City FROM Suppliers</span><br>
        ORDER BY City;<br><br>

        <!-- C2 UNION ALL -->
        <span class="C2">SELECT City FROM Customers<br>
        UNION ALL<br>
        SELECT City FROM Suppliers</span><br>
        ORDER BY City;<br><br>

        <!-- C3 UNION from three tables -->
        <span class="C3">SELECT City FROM Customers<br>
        UNION<br>
        SELECT City FROM Suppliers<br>
        UNION<br>
        SELECT City FROM Employees;</span><br><br>

        <!-- C4 UNION with WHERE -->
        <span class="C4">SELECT City, Country FROM Customers<br>
        WHERE Country = 'Germany'<br>
        UNION<br>
        SELECT City, Country FROM Suppliers<br>
        WHERE Country = 'Germany';</span>

      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUT -->
    <h3>Example Output:</h3>

    <!-- C1 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C1"><th>City</th></tr>
      <tr><td>Berlin</td></tr>
      <tr><td>Madrid</td></tr>
      <tr><td>New Orleans</td></tr>
    </table>

    <br>

    <!-- C2 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C2"><th>City</th></tr>
      <tr><td>Berlin</td></tr>
      <tr><td>Berlin</td></tr>
      <tr><td>Berlin</td></tr>
      <tr><td>Madrid</td></tr>
      <tr><td>New Orleans</td></tr>
    </table>

    <br>

    <!-- C3 Output -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C3"><th>City</th></tr>
      <tr><td>Berlin</td></tr>
      <tr><td>London</td></tr>
      <tr><td>Madrid</td></tr>
      <tr><td>New Orleans</td></tr>
    </table>

    <br>

    <!-- C4 Output (Now Multiple Rows) -->
    <table class="example" border="1" cellspacing="0" cellpadding="5">
      <tr class="C4"><th>City</th><th>Country</th></tr>
      <tr><td>Berlin</td><td>Germany</td></tr>
      <tr><td>Hamburg</td><td>Germany</td></tr>
    </table>

    <!-- 3. EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">

      <span class="C1"><code>UNION</code></span>
      <span>
        – Combines result sets and automatically removes duplicate rows.
      </span><br>

      <span class="C2"><code>UNION ALL</code></span>
      <span>
        – Combines result sets but keeps duplicates. Faster because no duplicate-check step happens.
      </span><br>

      <span class="C3"><code>Multiple UNION statements</code></span><br>
      <span>
        You can combine more than two SELECT statements.<br>
        Each additional UNION keeps stacking results vertically.<br>
        This works also for UNION ALL
      </span><br>

      <span class="C4"><code>WHERE + UNION</code></span>
      <span>
        – Each SELECT filters independently before combining.
      </span><br><br>

      <strong>Notes:</strong><br>
      <span>
        - All SELECT statements must have the same number of columns.<br>
        &nbsp;&nbsp;-- ✅ Works: same number of columns<br>
        &nbsp;&nbsp;SELECT City, Country FROM Customers<br>
        &nbsp;&nbsp;UNION<br>
        &nbsp;&nbsp;SELECT City, Country FROM Suppliers;<br><br>

        &nbsp;&nbsp;-- ❌ Error: different number of columns<br>
        &nbsp;&nbsp;SELECT City FROM Customers<br>
        &nbsp;&nbsp;UNION<br>
        &nbsp;&nbsp;SELECT City, Country FROM Suppliers;<br><br>
        - Column data types must be compatible.<br>
        - Column order must match exactly.<br>
        - Result column names come from the first SELECT statement.
      </span><br><br>

      <strong>UNION vs JOIN:</strong><br>
      <span>
        - UNION adds rows (vertical merge).<br>
        - JOIN adds columns (horizontal merge using keys).<br><br>
        UNION = stack data.<br>
        JOIN = connect related data.
      </span><br><br>

      <strong>Concept & Spirit:</strong><br>
      <span>
        UNION teaches consolidation of similar structured datasets. 
        It reinforces thinking about compatibility and schema alignment. 
        JOIN teaches relationships. UNION teaches structural merging.
      </span>

    </div>

  </div>

</template>

<!-- 6. Modifying Data -->

<!-- 7. Database Design, Integrity & Safety -->