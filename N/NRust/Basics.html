<!-- File name: N/NRust/Rust.html -->

<template> <!-- RUST: Ownership & Borrowing -->

  <div class="bubble">

    <!-- 1. CODE BLOCKS -->
    <h3>Topic Title: Rust Ownership & Borrowing</h3>
    <div class="code_block">
      <code>
        <!-- Ownership Rules -->
        // Ownership Rules <br>
        <span class="C1">let x = 5;</span><br>
        <span class="C1">let y = x; // x is moved to y</span><br><br>

        <!-- Clone -->
        // Clone <br>
        <span class="C2">let x = 5;</span><br>
        <span class="C2">let y = x.clone(); // explicitly clone value</span><br><br>

        <!-- Borrowing -->
        // Borrowing & References <br>
        <span class="C3">let s = String::from("hello");</span><br>
        <span class="C3">let r = &s; // borrow s</span><br><br>

        <!-- Mutable References -->
        // Mutable References <br>
        <span class="C4">let mut s = String::from("hello");</span><br>
        <span class="C4">&nbsp;&nbsp;let r = &mut s; // mutable borrow</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUTS -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; x is no longer valid after moving to y (C1)</span><br>
      <span class="dot d2"></span><span> &rarr; x is still usable because we cloned it (C2)</span><br>
      <span class="dot d3"></span><span> &rarr; r can read s without taking ownership (C3)</span><br>
      <span class="dot d4"></span><span> &rarr; r can modify s safely when borrowed mutably (C4)</span><br>
    </div>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>let x = 5;</code></span>
      <span> ‚Äì x owns the value 5. When we assign x to y, ownership moves to y, and x can no longer be used. This ensures Rust automatically frees memory safely when a value goes out of scope.</span><br>

      <span class="C2"><code>x.clone()</code></span>
      <span> ‚Äì Cloning creates a full copy of the value so both x and y have independent ownership. Use cloning when you need to preserve the original value while giving a copy to another variable.</span><br>

      <span class="C3"><code>&s</code></span>
      <span> ‚Äì Borrowing a reference lets you read a value without taking ownership. The original owner (s) keeps control, preventing accidental invalid memory access, while you can safely use the data temporarily.</span><br>

      <span class="C4"><code>&mut s</code></span>
      <span> ‚Äì Mutable references allow you to modify a value without taking ownership. Rust ensures there‚Äôs only one mutable reference at a time, preventing conflicts and guaranteeing safe, predictable changes.</span><br>

      <span class="C5"><code>Ownership Concept</code></span>
      <span> ‚Äì Rust‚Äôs ownership system is the foundation for memory safety. It removes the need for a garbage collector, while preventing bugs like dangling pointers or double frees.</span><br>

      <span class="C6"><code>Borrowing Concept</code></span>
      <span> ‚Äì Borrowing allows you to use or modify data safely without giving up ownership. It encourages thinking about who ‚Äúowns‚Äù data at any time and avoids unnecessary cloning, making programs faster.</span><br>

      <span class="C7"><code>Why This Matters</code></span>
      <span> ‚Äì By enforcing ownership and borrowing rules, Rust ensures memory is always valid and accessible only by permitted parts of your program, improving reliability and preventing subtle bugs common in other languages.</span><br><br>

      <!-- 3.2 NOTES -->
      <h3>Notes:</h3>
      <span>- Each value has exactly one owner unless borrowed.</span><br>
      <span>- Ownership ensures memory is freed automatically when out of scope.</span><br>
      <span>- Borrowing avoids expensive clones for large values.</span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <h3>Concept & Spirit:</h3>
      <span>- Unlike other coding languages, keep in mind you're always either owning a variable or borrowing a variable</span><br>
      <span>- Ownership is Rust‚Äôs way of managing memory safely without a garbage collector.</span><br>
      <span>- Borrowing encourages safe reuse of data without transferring ownership.</span><br>
      <span>- These rules prevent common bugs like dangling pointers or double frees and are part of what makes Rust fast and reliable.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: Strings -->

  <div class="bubble">

    <!-- 1. CODE BLOCKS -->
    <h3>Topic Title: Rust Strings ‚Äì Working with &str and String</h3>
    <div class="code_block">
      <code>
        <!-- Section 1 -->
        // String slices (&str) <br>
        <span class="C1">let greeting: &str = "Hello";</span><br><br>

        <!-- Section 2 -->
        // Create a String from &str <br>
        <span class="C2">let s1 = "Hi".to_string();</span><br>
        <span class="C2">let s2 = String::from("Hola");</span><br><br>

        <!-- Section 3 -->
        // Change a mutable String <br>
        <span class="C3">let mut s3 = String::from("Hello");</span><br>
        <span class="C3">&nbsp;&nbsp;s3.push_str(", world!");</span><br><br>

        <!-- Section 4 -->
        // Concatenate with + and format! <br>
        <span class="C4">let s4 = s1 + &s2;</span><br>
        <span class="C4">let s5 = format!("{} {}", s2, s3);</span><br><br>

        <!-- Section 5 -->
        // Find String length <br>
        <span class="C5">let length = s5.len();</span><br>
      </code>
    </div>

    <!-- 2. EXAMPLE OUTPUTS -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> ‚Üí Fixed slice "Hello"</span><br>
      <span class="dot d2"></span><span> ‚Üí Creates owned Strings: "Hi", "Hola"</span><br>
      <span class="dot d3"></span><span> ‚Üí Mutated string becomes "Hello, world!"</span><br>
      <span class="dot d4"></span><span> ‚Üí Concatenated: "HiHola" and "Hola Hello, world!"</span><br>
      <span class="dot d5"></span><span> ‚Üí Length of string in bytes (e.g., 18)</span><br>
    </div>

    <!-- 3.1 EXPLANATION -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>&str</code></span><span> ‚Äì Pronounced ‚Äústring slice.‚Äù Think of it as a window into some text that already exists. You can look through the window and read the words, but you don‚Äôt own the house, so you can‚Äôt knock down walls or expand it. That‚Äôs why slices like <code>"Hello"</code> are fixed and unchangeable.</span><br><br>

      <span class="C2"><code>String</code></span><span> ‚Äì A <code>String</code> is like moving the text into your own house. Now you own it, and you can rearrange it however you want. You can build more rooms (add characters) or repaint walls (modify the content). That‚Äôs why <code>to_string()</code> and <code>String::from()</code> both ‚Äútake‚Äù the borrowed slice and give you a fresh owned <code>String</code> that you control.</span><br><br>

      <span class="C3"><code>mut</code> + <code>push_str()</code></span><span> ‚Äì Rust doesn‚Äôt let you change things unless you clearly say they‚Äôre mutable (<code>mut</code>). Declaring <code>mut s3</code> is like saying ‚Äúthis string is flexible.‚Äù Then <code>push_str()</code> works like taping more paper onto the end of a scroll. Each time you call it, the string grows.</span><br><br>

      <span class="C4"><code>Concatenate</code></span><span> ‚Äì The word ‚Äúconcatenate‚Äù simply means ‚Äúto join things together end-to-end.‚Äù In strings, it means gluing words one after another. The <code>+</code> operator does this, but with a catch: the first string is consumed (Rust gives up ownership of it) and then adds a borrowed piece (<code>&str</code>) onto the end. The <code>format!</code> macro is safer and cleaner‚Äîit doesn‚Äôt take ownership away and works with multiple values at once, like filling in blanks in a sentence.  
      Why both? The <code>+</code> operator is quick and low-level, good for two pieces. <code>format!</code> is the practical, everyday choice when building longer text.</span><br><br>

      <span class="C5"><code>.len()</code></span><span> ‚Äì This gives the length of the string, but in bytes, not characters. Why? Because Rust strings are UTF-8, which means some characters (like emoji or non-English letters) take more than one byte. For example, "a" is 1 byte, but "√©" is 2 bytes, and "üòä" is 4 bytes. This matters because if you assume <code>.len()</code> always means ‚Äúnumber of letters,‚Äù you can accidentally cut a character in half and corrupt the string. To count human-readable characters, use <code>.chars().count()</code>.</span><br><br>

      <span class="C6"><code>to_string()</code> vs <code>String::from()</code></span><span> ‚Äì These two are twins: they both convert a <code>&str</code> into an owned <code>String</code>. Which one you use is mostly personal style. Many Rustaceans prefer <code>to_string()</code> when starting from a literal (e.g. <code>"Hi".to_string()</code>) and <code>String::from()</code> when they want to be more explicit about ownership. Functionally, they‚Äôre the same.</span><br><br>

      <!-- 3.2 NOTES -->
      <h3>Notes:</h3>
      <span>- In Rust, ownership vs borrowing is a big deal. When you use <code>+</code>, the first <code>String</code> is moved and can‚Äôt be used anymore‚ÄîRust prevents hidden memory leaks by making ownership rules visible in code.</span><br>
      <span>- If you come from another language (like Python or JavaScript), you might expect all strings to be easy-to-edit. Rust forces you to say whether the data is borrowed (<code>&str</code>) or owned (<code>String</code>) so you know who controls the memory.</span><br>
      <span>- Rust‚Äôs strictness around mutability (<code>mut</code>) prevents accidental bugs where data changes unexpectedly. You always know which variables are frozen and which are flexible.</span><br>
      <span>- UTF-8 encoding is powerful because it supports every language and emoji, but it also means ‚Äúlength in bytes‚Äù is not always equal to ‚Äúlength in characters.‚Äù Rust makes you aware of this so you write safer, international-friendly code.</span><br><br>

      <!-- 3.3 CONCEPT & SPIRIT -->
      <h3>Concept & Spirit:</h3>
      <span>Rust‚Äôs string system may look strict at first, but it‚Äôs designed to teach you *who owns your data* and *what costs are being paid*. The reason these rules exist isn‚Äôt to slow you down‚Äîit‚Äôs to protect you from the hidden bugs other languages allow.  
      <br><br>
      ‚Ä¢ <code>&str</code> exists for efficiency: borrow when you don‚Äôt need to copy. <br> 
      ‚Ä¢ <code>String</code> exists for flexibility: own it when you need to grow or keep it.  <br>
      ‚Ä¢ <code>mut</code> ensures changes are deliberate.  <br>
      ‚Ä¢ <code>+</code> shows you ownership transfer; <code>format!</code> lets you build safely.  <br>
      ‚Ä¢ <code>.len()</code> shows you how Rust respects real encoding, instead of pretending all characters are equal.  <br><br>

      **Big picture:** Strings are one of the first places Rust shows its philosophy‚Äîmemory safety, clarity, and honesty about costs. Once you understand strings, you start to understand how Rust approaches everything else: don‚Äôt hide the details, make them explicit so your code is predictable and safe.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: Scope, Shadowing -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Scope: Variables and Shadowing</h3>
    <div class="code_block">
      <code>
        <!-- Section 1: Variable inside a function -->
        // Variable inside a function <br>
        <span class="C1">fn inside_function() { <br>
            &nbsp;&nbsp;let x = 5; <br>
            &nbsp;&nbsp;println!("Inside function, x = {}", x); <br>
        }</span><br><br>

        <!-- Section 2: Variable inside a block -->
        // Variable inside a block <br>
        <span class="C2">fn inside_block() { <br>
            &nbsp;&nbsp;let y = 10; <br>
            &nbsp;&nbsp;{ <br>
            &nbsp;&nbsp;&nbsp;&nbsp;let y = 20; <br>
            &nbsp;&nbsp;&nbsp;&nbsp;println!("Inside inner block, y = {}", y); <br>
            &nbsp;&nbsp;} <br>
            &nbsp;&nbsp;println!("Outside inner block, y = {}", y); <br>
        }</span><br><br>

        <!-- Section 3: Variables in the same scope with shadowing -->
        // Shadowing in the same scope <br>
        <span class="C3">fn shadowing_example() { <br>
            &nbsp;&nbsp;let z = 2; <br>
            &nbsp;&nbsp;let z = z + 3; // shadowing previous z <br>
            &nbsp;&nbsp;println!("After shadowing, z = {}", z); <br>
        }</span><br><br>

        <!-- Section 4: Calling functions -->
        // Calling functions <br>
        <span class="C4">fn main() { <br>
            &nbsp;&nbsp;inside_function(); <br>
            &nbsp;&nbsp;inside_block(); <br>
            &nbsp;&nbsp;shadowing_example(); <br>
        }</span>
      </code>
    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; Inside function, x = 5</span><br>
      <span class="dot d2"></span><span> &rarr; Inside inner block, y = 20</span><br>
      <span class="dot d2"></span><span> &rarr; Outside inner block, y = 10</span><br>
      <span class="dot d3"></span><span> &rarr; After shadowing, z = 5</span><br>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>let x = 5</code></span>
      <span> ‚Äì A variable created inside a function can only be used inside that function. 
      Once the function finishes, <code>x</code> disappears. This boundary is called the <em>function scope</em>. 
      Think of scope as the ‚Äúlifetime‚Äù of a variable ‚Äî when you leave the function, the variable‚Äôs memory is cleaned up.</span><br>

      <span class="C2"><code>let y = 20</code></span>
      <span> ‚Äì This is inside a <em>block</em>. A block in Rust is any piece of code wrapped in curly braces <code>{ }</code>. 
      A block creates its own smaller scope, like a mini-room inside a bigger room. 
      The <code>y</code> inside the block is separate from the <code>y</code> outside. 
      Inside the block, <code>y = 20</code>. Outside, <code>y = 10</code>. They are two different variables with the same name, 
      and the inner one vanishes when the block ends.</span><br>

      <span class="C3"><code>let z = z + 3</code></span>
      <span> ‚Äì This shows <strong>shadowing</strong>. Shadowing means you declare a new variable with the same name as an old one. 
      The first <code>z</code> is <code>2</code>. Then <code>let z = z + 3</code> creates a brand-new <code>z</code> (value <code>5</code>) 
      that <em>replaces</em> the old one. The old <code>z</code> is dropped, and only the new one exists. 
      Picture writing on a new sticky note and placing it over the old one ‚Äî the old note is hidden and thrown away, 
      not edited in place.</span><br>

      <span class="C4"><code>fn main()</code></span>
      <span> ‚Äì The entry point of every Rust program. Rust always looks for <code>main</code> first. 
      Without it, nothing runs (unless you‚Äôre writing a library). 
      In this example, <code>main</code> calls the functions so we can see how scope and shadowing work in action.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. A <strong>scope</strong> is the part of the code where a variable exists. 
      Functions, blocks, loops, and conditionals all create new scopes.</span><br>
      <span>2. <strong>Shadowing vs mutability:</strong> 
      - Shadowing (<code>let z = z + 3</code>) makes a brand-new variable. The old one is dropped, and memory is freed.  
      - Mutability (<code>let mut a = 1; a = 2;</code>) keeps the same variable, just updates its value in the same memory slot.  
      Shadowing can also change the type of a variable, while mutability cannot.</span><br>
      <span>3. Shadowing is useful when you want to reuse a name but transform its value step by step, 
      for example: <code>let x = "42"; let x: i32 = x.parse().unwrap();</code> 
      (string ‚Üí number). This would not be possible with just <code>mut</code>.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>- Rust enforces clear boundaries: variables live only as long as their scope.</span><br>
      <span>- This prevents hidden errors, like accidentally using a variable that should no longer exist.</span><br>
      <span>- Shadowing is Rust‚Äôs way of letting you reuse names while keeping transformations safe and predictable.</span><br>
      <span>- Overall, Rust encourages you to think carefully about data lifetimes, which reduces bugs and makes programs more reliable.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: Functions, Parameters, Return Values -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Functions: <code>fn</code>, Parameters, and Return Values</h3>
    <div class="code_block">
      <code>
        <!-- Section 1: Simple function -->
        // Simple function definition <br>
        <span class="C1">fn say_hello() { <br>
            &nbsp;&nbsp;println!("Hello, world!"); <br>
        }</span><br><br>

        <!-- Section 2: Function with parameters -->
        // Function with parameters <br>
        <span class="C2">fn greet(name: &str) { <br>
            &nbsp;&nbsp;println!("Hello, {}!", name); <br>
        }</span><br><br>

        <!-- Section 3: Function with explicit return -->
        // Function with explicit return <br>
        <span class="C3">fn add_explicit(a: i32, b: i32) -> i32 { <br>
            &nbsp;&nbsp;return a + b; <br>
        }</span><br><br>

        <!-- Section 4: Function with implicit return -->
        // Function with implicit return (last expression) <br>
        <span class="C4">fn add_implicit(a: i32, b: i32) -> i32 { <br>
            &nbsp;&nbsp;a + b <br>
        }</span><br><br>

        <!-- Section 5: Calling functions -->
        // Calling functions <br>
        <span class="C5">fn main() { </span><br>
            <span class="C1">&nbsp;&nbsp;say_hello(); </span><br>
            <span class="C2">&nbsp;&nbsp;greet("Alice"); </span><br>
            <span class="C3">&nbsp;&nbsp;let sum1 = add_explicit(5, 7); </span><br>
            <span class="C5">&nbsp;&nbsp;println!("Sum with explicit return: {}", sum1); </span><br>
            <span class="C4">&nbsp;&nbsp;let sum2 = add_implicit(3, 4); </span><br>
            <span class="C5">&nbsp;&nbsp;println!("Sum with implicit return: {}", sum2); <br>
        }</span>
      </code>
    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; Hello, world!</span><br>
      <span class="dot d2"></span><span> &rarr; Hello, Alice!</span><br>
      <span class="dot d3"></span><span> &rarr; Sum with explicit return: 12</span><br>
      <span class="dot d4"></span><span> &rarr; Sum with implicit return: 7</span><br>
      <span class="dot d5"></span><span> &rarr; But called through main</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>fn say_hello()</code></span><span> ‚Äì A function with no parameters and no return value.</span><br>
      <span class="C2"><code>fn greet(name: &str)</code></span><span> ‚Äì Takes one parameter called <code>name</code>. Notice that in Rust you must always specify the type (<code>&str</code> here means a string slice).</span><br>
      <span class="C3"><code>fn add_explicit(a: i32, b: i32) -> i32</code></span><span> ‚Äì Uses the <code>return</code> keyword to send back the sum. This is the ‚Äúlong-form‚Äù way.</span><br>
      <span class="C4"><code>fn add_implicit(a: i32, b: i32) -> i32</code></span><span> ‚Äì Does the same, but without <code>return</code>. In Rust, the last line of a function (if it has no semicolon) is automatically returned.</span><br>
      <span class="C5"><code>fn main()</code></span><span> ‚Äì The entry point of every Rust program. Rust always starts by looking for <code>main</code>. Without it, nothing runs (unless you are writing a library). Here it calls the other functions and prints their results.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. Both explicit <code>return</code> and implicit return work the same. The difference is style: explicit is clearer in long or complex code, implicit is shorter and common for simple math or logic.</span><br>
      <span>2. In Rust, every parameter must have a type. This makes your code safer and avoids confusion.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>- Rust wants you to be <em>clear about data flow</em>. Parameters are the inputs, return values are the outputs.</span><br>
      <span>- Implicit returns encourage short, readable functions where the last expression is the ‚Äúanswer.‚Äù</span><br>
      <span>- Explicit <code>return</code> is useful when you want to exit early or make the return very obvious.</span><br>
      <span>- Overall, Rust functions are designed to be predictable: you always know what goes in and what comes out.</span><br>
      <span>- This makes programs easier to read, safer, and less error-prone compared to languages that guess types or hide return values.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: loops, while, for. -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Loops: <code>loop</code>, <code>while</code>, and <code>for</code></h3>
    <div class="code_block">

      <!-- Section 1: Infinite loop -->
      <code>// Infinite loop (‚ö†Ô∏è press Ctrl + C to stop)</code><br>
      <span class="C1"><code>loop {</code><br>
      <code>&nbsp;&nbsp;println!("This runs forever!");</code><br>
      <code>}</code></span><br><br>

      <!-- Section 2: loop with break -->
      <code>// loop with break returning a value</code><br>
      <span class="C2"><code>let mut counter = 0;</code><br>
      <code>let result = loop {</code><br>
      <code>&nbsp;&nbsp;counter += 1;</code><br>
      <code>&nbsp;&nbsp;if counter == 3 {</code><br>
      <span class="C6"><code>&nbsp;&nbsp;&nbsp;&nbsp;break counter * 2; // returns 6</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>};</code><br>
      <code>println!("Result: {}", result);</code></span><br><br>

      <!-- Section 3: while loop -->
      <code>// while loop countdown</code><br>
      <span class="C3"><code>let mut number = 3;</code><br>
      <code>while number != 0 {</code><br>
      <code>&nbsp;&nbsp;if number == 2 {</code><br>
      <span class="C7"><code>&nbsp;&nbsp;&nbsp;&nbsp;number -= 1; continue; // skips printing 2</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>&nbsp;&nbsp;println!("{}", number);</code><br>
      <code>&nbsp;&nbsp;number -= 1;</code><br>
      <code>}</code><br>
      <code>println!("LIFTOFF!");</code></span><br><br>

      <!-- Section 4: for loop -->
      <code>// for loop over collection</code><br>
      <span class="C4"><code>let arr = [10, 20, 30];</code><br>
      <code>for val in arr.iter() {</code><br>
      <code>&nbsp;&nbsp;if *val == 20 {</code><br>
      <span class="C6"><code>&nbsp;&nbsp;&nbsp;&nbsp;break; // exit loop early</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>&nbsp;&nbsp;println!("Value: {}", val);</code><br>
      <code>}</code></span><br><br>

    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <!-- loop (infinite) ‚Üí no output shown -->
      <span class="dot d2"></span><span> &rarr; Prints: Result: 6</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: 3</span><br>
      <span class="dot d7"></span><span> &rarr; Skips printing 2 (continue)</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: 1</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: LIFTOFF!</span><br>
      <span class="dot d4"></span><span> &rarr; Prints: Value: 10</span><br>
      <span class="dot d6"></span><span> &rarr; Break stops before printing 20 or 30</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>loop</code></span><span> ‚Äì Creates an infinite loop unless ended with <span class="C6">break</span>.</span><br>
      <span class="C2"><code>loop ... break value</code></span><span> ‚Äì A loop can return a value when you <span class="C6">break</span> with an expression. Example: 6.</span><br>
      <span class="C3"><code>while</code></span><span> ‚Äì Runs while the condition is true. Example: countdown skips printing 2 due to <span class="C7">continue</span>.</span><br>
      <span class="C4"><code>for</code></span><span> ‚Äì Iterates over a collection. Example: breaks early when hitting 20 using <span class="C6">break</span>.</span><br>
      <span class="C6"><code>break</code></span><span> ‚Äì Exits the loop immediately. Works in <code>loop</code>, <code>while</code>, and <code>for</code>.</span><br>
      <span class="C7"><code>continue</code></span><span> ‚Äì Skips the rest of the current iteration and moves to the next. Works in all loop types.</span><br><br>

      <strong>Notes:</strong><br>
      <span>
        1. Infinite loops are rarely needed; always pair with <span class="C6">break</span> for control.<br>
        2. Returning values from loops (<span class="C6">break expr</span>) is unique to Rust.<br>
        3. <span class="C7">continue</span> is useful for filtering values inside loops.<br>
        4. Prefer <code>for</code> for collections, <code>while</code> for conditions, <code>loop</code> for manual control.<br>
        5. <code>arr.iter()</code> creates an iterator of references ‚Äî you‚Äôre borrowing each element instead of copying it. This is efficient and avoids unnecessary allocations.<br>
          - <code>iter()</code> ‚Üí &T (immutable borrow)<br>
          - <code>iter_mut()</code> ‚Üí &mut T (mutable borrow)<br>
          - <code>into_iter()</code> ‚Üí T (moves ownership)<br>
          Rust gives explicit control over access and ownership.<br><br>

        <strong>Concept & Spirit of Rust:</strong><br>
        <span>
          - Rust loops help you <strong>repeat actions safely</strong> and <strong>control exactly how your program runs</strong>.<br>
          - <code>loop</code> runs forever unless you use <span class="C6">break</span>. <code>while</code> runs as long as a condition is true. <code>for</code> iterates over collections. This gives you <strong>flexibility with safety</strong>.<br>
          - Using <span class="C6">break</span> or <span class="C7">continue</span> makes your intentions explicit: you control <strong>when a loop stops</strong> or <strong>skips a step</strong>.<br>
          - Iterators like <code>arr.iter()</code> <strong>borrow elements</strong> instead of copying them, so your code is <strong>efficient and safe</strong>. You don‚Äôt accidentally change or duplicate data.<br>
          - Rust encourages you to <strong>think about ownership and borrowing</strong> from the start. Loops and iterators are just one example of how Rust keeps memory and data access predictable.<br>
          - Overall: Rust makes you write code that is <strong>deliberate, clear, and safe</strong>, while still being expressive and powerful. Loops are tools that let you do repetitive tasks <strong>without accidentally creating bugs or memory issues</strong>.<br>
        </span>
    </div>

  </div>
</template>

<template> <!-- Rust: If ... else ... / Switch -> in Rust use -> Match -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Code: If / Else / Match</h3>
    <div class="code_block">
      <!-- If..Else Section -->
      <code>// If..Else Example</code><br>
      <span class="C1"><code>let number = 7;</code></span><br>
      <span class="C2"><code>let result = <br>
        if number % 2 == 0 <br>
        &nbsp;&nbsp;{ "Even" } <br> 
        else <br> 
        &nbsp;&nbsp;{ "Odd" };</code></span><br>
      <span class="C3"><code>println!("Number is {}", result);</code></span><br><br>

      <!-- Match Section -->
      <code>// Match Example</code><br>
      <span class="C4"><code>let day = 3;</code></span><br>
      <span class="C5"><code>let day_name = match day {</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;1 => "Monday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;2 => "Tuesday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;3 => "Wednesday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;_ => "Other",</code></span><br>
      <span class="C5"><code>};</code></span><br>
      <span class="C7"><code>println!("Day is {}", day_name);</code></span><br>
    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <span class="dot d2"></span><span> &rarr; Number is Odd</span><br>
      <span class="dot d7"></span><span> &rarr; Day is Wednesday</span><br>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1">let number</span><span> ‚Äì Declares a variable storing a number.</span><br>
      <span class="C2">if .. else</span><span> ‚Äì Conditional expression; both branches must return the same type. Here, both return &quot;Even&quot; or &quot;Odd&quot; (strings).</span><br>
      <span class="C3">println!</span><span> ‚Äì Prints the value of <code>result</code> to the console.</span><br>
      <span class="C4">let day</span><span> ‚Äì Declares the variable to match against.</span><br>
      <span class="C5">match</span><span> ‚Äì Pattern matching; similar to a ‚Äúswitch‚Äù in other languages but safer and more powerful. Must return same type for all branches.</span><br>
      <span class="C6">branch values</span><span> ‚Äì Each pattern (1,2,3) maps to a string. The underscore <code>_</code> acts as the default case (like ‚Äúdefault‚Äù in switch).</span><br>
      <span class="C7">println!</span><span> ‚Äì Prints <code>day_name</code> to console.</span><br><br>

      <strong>Notes:</strong><br>
      <span>
      <strong class="C2">1. Expression vs Statement:</strong><br>  
        - An <code>expression</code> produces a value (can be assigned to a variable).  <br> 
          Example: <code>let x = 5 + 3;</code> ‚Üí <code>5 + 3</code> is an expression returning 8.  <br> 
        - A <code>statement</code> performs an action but doesn‚Äôt return a value.  <br> 
          Example: <code>let y = 10;</code> is a statement (declares variable, no value returned directly).  <br> 
        - In Rust, <code>if..else</code> is an expression; it returns a value that can be assigned.  <br><br>  

      <strong class="C5">2. Why use match instead of a switch:</strong>  <br> 
        - Rust does not have a traditional ‚Äúswitch‚Äù like C/JS.  <br> 
        - <code>match</code> is safer: it forces **exhaustive checking** (all possible cases must be handled).  <br> 
        - Returns a value (like an expression), unlike most switch statements that don‚Äôt return values.  <br> 
        - Can match complex patterns (enums, tuples, ranges), which a switch cannot.  <br><br>  

      <strong class="C5">3.  Default case (_)</strong>:  <br> 
        - The underscore <code>_</code> acts as a ‚Äúcatch-all‚Äù for any unmatched values.  <br> 
        - Pick it when you want to handle all remaining possibilities not explicitly listed.  <br> 
        - Ensures the match expression is exhaustive; Rust will give a compile error if some value is not covered.  <br><br>  

      <strong class="C2">4. Type requirement:</strong>  <br> 
        - Every branch of <code>if..else</code> or <code>match</code> must return the same type.  <br> 
        - Example: you cannot have one branch return a string and another return a number.  <br><br> 

      <strong>5. Practical tip:</strong>  <br> 
        - Use <code>if..else</code> for simple two-way decisions.  <br> 
        - Use <code>match</code> for multiple options, exhaustive checks, or pattern matching scenarios.  <br> 
      </span><br> 

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>
      - Rust emphasizes **expressions over statements**, meaning many constructs (like <code>if..else</code> and <code>match</code>) produce values that can be used immediately.<br>
      - Pattern matching with <code>match</code> reflects Rust‚Äôs philosophy of **safety and exhaustiveness**: you must consider all possible cases, reducing runtime errors.<br>
      - Rust encourages thinking in terms of **ownership, borrowing, and predictable behavior**. Conditionals don‚Äôt just control flow‚Äîthey interact with values and ownership explicitly.<br>
      - The language design nudges you to **write clear, explicit, and memory-safe code**. Each branch returning a consistent type, and exhaustive pattern matching, are examples of this principle.<br>
      - Conceptually, Rust is about **being deliberate**: you explicitly decide how data is handled, how values flow, and how each construct affects program state. This mindset underpins loops, conditionals, and iterators alike.
    </span>
    </div>

  </div>
</template>

<template> <!-- Rust: Operations -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Code: Operators</h3>
    <div class="code_block">

      <!-- Arithmetic Operators -->
      <code>// Arithmetic Operators</code>
      <span class="C1"><br>
        <code>let sum = 5 + 3;</code><br>
        <code>let difference = 5 - 3;</code><br>
        <code>let product = 5 * 3;</code><br>
        <code>let quotient = 10 / 2;</code><br>
        <code>let remainder = 10 % 3;</code><br>
      </span><br>

      <!-- Assignment Operators -->
      <code>// Assignment Operators</code>
      <span class="C2"><br>
        <code>let mut x = 5;</code><br>
        <code>x += 3;</code><br>
        <code>x -= 2;</code><br>
        <code>x *= 4;</code><br>
        <code>x /= 2;</code><br>
        <code>x %= 2;</code><br>
      </span><br>

      <!-- Comparison Operators -->
      <code>// Comparison Operators</code>
      <span class="C3"><br>
        <code>5 == 5</code><br>
        <code>5 != 3</code><br>
        <code>7 > 3</code><br>
        <code>2 < 5</code><br>
        <code>5 >= 5</code><br>
        <code>3 <= 4</code><br>
      </span><br>

      <!-- Logical Operators -->
       <code>// Logical Operators</code>
      <span class="C4"><br>
        <code>true && false</code><br>
        <code>true || false</code><br>
        <code>!true</code><br>
      </span>

    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <!-- Arithmetic -->
      <span class="dot d1"></span><span> &rarr; 8</span><br>
      <span class="dot d1"></span><span> &rarr; 2</span><br>
      <span class="dot d1"></span><span> &rarr; 15</span><br>
      <span class="dot d1"></span><span> &rarr; 5</span><br>
      <span class="dot d1"></span><span> &rarr; 1</span><br>

      <!-- Assignment -->
      <span class="dot d2"></span><span> &rarr; x = 8 after x += 3</span><br>
      <span class="dot d2"></span><span> &rarr; x = 6 after x -= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 24 after x *= 4</span><br>
      <span class="dot d2"></span><span> &rarr; x = 12 after x /= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 0 after x %= 2</span><br>

      <!-- Comparison -->
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>

      <!-- Logical -->
      <span class="dot d4"></span><span> &rarr; false</span><br>
      <span class="dot d4"></span><span> &rarr; true</span><br>
      <span class="dot d4"></span><span> &rarr; false</span><br>
    </div>

      <!-- Explanation Section -->
      <h3>Explanation:</h3>
      <div class="explanation">

        <span class="C1">+</span> adds two numbers. 5 + 3 ‚Üí 8.<br>
        <span class="C1">-</span> subtracts one number from another. 5 - 3 ‚Üí 2.<br>
        <span class="C1">*</span> multiplies numbers. 5 * 3 ‚Üí 15.<br>
        <span class="C1">/</span> divides numbers. 10 / 2 ‚Üí 5.<br>
        <span class="C1">%</span> gives the remainder of a division. 10 % 3 ‚Üí 1.<br><br>

        <span class="C2">=</span> assigns a value to a variable.<br>
        <span class="C2">+=</span> adds to the current value. x += 3 adds 3 to x.<br>
        <span class="C2">-=</span> subtracts from the current value.<br>
        <span class="C2">*=</span> multiplies the current value.<br>
        <span class="C2">/=</span> divides the current value.<br>
        <span class="C2">%=</span> replaces the value with the remainder of division.<br>
        Variables must be mutable (mut) to use these operators.<br><br>

        <span class="C3">==</span> checks if two values are equal. 5 == 5 ‚Üí true.<br>
        <span class="C3">!=</span> checks if two values are not equal. 5 != 3 ‚Üí true.<br>
        <span class="C3">&gt;</span> checks if the left value is greater than the right. 7 > 3 ‚Üí true.<br>
        <span class="C3">&lt;</span> checks if the left value is less than the right. 2 < 5 ‚Üí true.<br>
        <span class="C3">&gt;=</span> checks if the left value is greater than or equal to the right. 5 >= 5 ‚Üí true.<br>
        <span class="C3">&lt;=</span> checks if the left value is less than or equal to the right. 3 <= 4 ‚Üí true.<br><br>

        <span class="C4">&&</span> (AND) is true only if both values are true. true && false ‚Üí false.<br>
        <span class="C4">||</span> (OR) is true if at least one value is true. true || false ‚Üí true.<br>
        <span class="C4">!</span> (NOT) inverts a boolean value. !true ‚Üí false.<br><br>

        <strong>Notes:</strong><br>
        Arithmetic operators work on numeric types (i32, f32, etc.).<br>
        Assignment operators require mutable variables.<br>
        Comparison and logical operators return boolean values.<br>
        Rust does not allow mixing numeric types without explicit casting.<br><br>

        <strong>Concept & Spirit of Rust:</strong><br>
        <span>
        - Rust makes you **think about your code carefully**. You must decide when a value can change (mutable) and when it cannot.<br>
        - All operations (math, assignment, comparison, logic) are **safe by default**. Rust won‚Äôt do hidden conversions or guesses like some other languages.<br>
        - Using <code>mut</code> shows clearly when a variable is allowed to change. This makes your program easier to understand and less likely to have mistakes.<br>
        - Boolean operations (true/false checks) are clear and predictable ‚Äî no surprises.<br>
        - The overall idea is to write code that is **explicit, clear, and safe**, so you always know what the program is doing with your data.
      </span>

    </div>

  </div>
</template>

<template> <!-- Rust: Basics -->
  <div class="bubble">

    <h3>Rust Code: Fundamentals:</h3>

    <!-- Code Block -->
    <div class="code_block">
      <!-- Comments -->
      <code>// Single-line comment</code><br>
      <span class="C1"><code>// This is a comment</code><br>
      <code>/* This is a block comment */</code></span><br><br>

      <!-- Variables -->
      <code>// Variables</code><br>
      <span class="C2"><code>let x = 5;          // immutable integer</code><br>
      <code>let mut y = 10;      // mutable integer</code></span><br><br>

      <!-- Data Types -->
      <code>// Data Types</code><br>
      <span class="C3"><code>let my_num: i32 = 5;</code><br>
      <code>let my_double: f64 = 5.99;</code><br>
      <code>let my_letter: char = 'D';</code><br>
      <code>let my_bool: bool = true;</code><br>
      <code>let my_text: &str = "Hello";</code></span><br><br>

      <code>// Type-inferred Data Types</code><br>
      <span class="C4"><code>let my_num = 5;</code><br>
      <code>let my_double = 5.99;</code><br>
      <code>let my_letter = 'D';</code><br>
      <code>let my_bool = true;</code><br>
      <code>let my_text = "Hello";</code></span><br><br>

      <!-- Printing -->
      <code>// Printing Examples</code><br>
      <span class="C5"><code>print!("Hello ");</code><br>
      <code>println!("World!");</code></span><br>
      <span class="C6"><code>let name = "Liam";</code><br>
      <code>println!("Hello, {}", name);</code></span><br>
      <span class="C6"><code>let age = 21;</code><br>
      <code>println!("{} is {} years old", name, age);</code></span><br>
      <span class="C6"><code>println!("First {0}, Second {1}, Again {0}", 10, 20);</code></span><br>
      <span class="C6"><code>println!("Hi {name}", name="Bob");</code></span><br><br>

      <!-- Constants -->
      <code>// Constants</code><br>
      <span class="C7"><code>const MAX_SPEED: i32 = 120;</code><br>
      <code>const PI: f64 = 3.14159;</code><br>
      <code>const MINUTES_PER_HOUR: i32 = 60;</code></span>
    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <span class="dot d5"></span><span> &rarr; Prints: Hello World!</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hello, Liam</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Liam is 21 years old</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: First 10, Second 20, Again 10</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hi Bob</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1">//, /* */</span><span> ‚Äì Comments are ignored by the compiler. </span><br>
      <span>Example: You can write </span><code>// explain what x does</code><span> and it won‚Äôt affect the program.</span><br><br>

      <span class="C2">let / mut</span><span> ‚Äì <code>let</code> creates a variable. By default it‚Äôs immutable (cannot change). </span><br>
      <span>Example: <code>let x = 5;</code> ‚Üí trying <code>x = 6;</code> gives an error. </span><br>
      <span>Use <code>let mut y = 10;</code> if you want to change it later (<code>y = 20;</code> works).</span><br><br>

      <span class="C3">Explicit types</span><span> ‚Äì You can declare the type directly. </span><br>
      <code>let my_num: i32 = 5;</code><span>, <code>let my_double: f64 = 5.99;</code>. </span><br>
      <span>This makes your code clearer and avoids mistakes (like wrong type assumptions).</span><br><br>

      <span class="C4">Type inference</span><span> ‚Äì If you skip the type, Rust figures it out. </span><br>
      <code>let my_num = 5;</code><span> ‚Üí compiler knows it‚Äôs an <code>i32</code>. </span><br>
      <code>let my_double = 5.99;</code><span> ‚Üí compiler knows it‚Äôs an <code>f64</code>.</span><br>
      <span>You write the type explicitly if you want clarity, or when Rust can‚Äôt guess correctly.</span><br><br>

      <span class="C5">print!/println!()</span><span> ‚Äì <code>print!</code> does not add a new line, <code>println!</code> does. </span><br><br>

      <span class="C6">Placeholders {}</span><span> ‚Äì Pull values into your string. </span><br>
      <span>Example: </span><code>println!("Hello, {}", name);</code><span> ‚Üí if <code>name = "Liam"</code>, prints <code>Hello, Liam</code>.</span><br>
      <span>You can use multiple placeholders: </span><code>println!("{} is {}", name, age);</code><br>
      <span>You can reuse positions: </span><code>{0}, {1}</code><br>
      <span>You can also name them: </span><code>println!("Hi {name}", name="Bob");</code><br><br>

      <span class="C7">const</span><span> ‚Äì Constants never change and must always have a type. </span><br>
      <span>Example: </span><code>const PI: f64 = 3.14159;</code><span> ‚Üí always the same, anywhere in your code.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. Variables declared with <code>let</code> are immutable unless <code>mut</code> is used.</span><br>
      <span>2. Constants (<code>const</code>) are always immutable and must have a type.</span><br>
      <span>3. Comparison between constants and variables:</span><br><br>

      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>Feature</th>
          <th>Constant (<code>const</code>)</th>
          <th>Variable (<code>let</code>)</th>
        </tr>
        <tr>
          <td>Can change?</td>
          <td>No</td>
          <td>Yes, if <code>mut</code> is used</td>
        </tr>
        <tr>
          <td>Type required?</td>
          <td>Yes (must be written)</td>
          <td>No (can be inferred)</td>
        </tr>
      </table><br>

      <span>4. Use constants for fixed values like <code>PI</code> or <code>MINUTES_PER_HOUR</code>.</span><br>
      <span>5. Use <code>let</code> / <code>mut</code> for values that may change during program execution.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>
      - Rust wants you to **be clear about what can change and what cannot**. Variables are immutable by default, and constants never change ‚Äî this prevents mistakes.<br>
      - Types are explicit or inferred, but Rust makes you aware of what each value is. This helps avoid unexpected errors.<br>
      - Printing with placeholders shows that Rust separates **data** from **how it‚Äôs displayed**, making output safe and predictable.<br>
      - Overall, Rust encourages **writing safe, predictable, and clear code**. Every decision ‚Äî whether a value can change, how it‚Äôs stored, and how it‚Äôs printed ‚Äî is intentional. This is the ‚Äúspirit‚Äù behind Rust.
    </span>
    </div>

  </div>
</template>

<!-- 
Yet to be tested.




-->