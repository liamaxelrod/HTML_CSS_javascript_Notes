<!-- File name: N/NRust/Rust.html -->

<template> <!-- RUST: Scope, Shadowing -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Scope: Variables and Shadowing</h3>
    <div class="code_block">
      <code>
        <!-- Section 1: Variable inside a function -->
        // Variable inside a function <br>
        <span class="C1">fn inside_function() { <br>
            &nbsp;&nbsp;let x = 5; <br>
            &nbsp;&nbsp;println!("Inside function, x = {}", x); <br>
        }</span><br><br>

        <!-- Section 2: Variable inside a block -->
        // Variable inside a block <br>
        <span class="C2">fn inside_block() { <br>
            &nbsp;&nbsp;let y = 10; <br>
            &nbsp;&nbsp;{ <br>
            &nbsp;&nbsp;&nbsp;&nbsp;let y = 20; <br>
            &nbsp;&nbsp;&nbsp;&nbsp;println!("Inside inner block, y = {}", y); <br>
            &nbsp;&nbsp;} <br>
            &nbsp;&nbsp;println!("Outside inner block, y = {}", y); <br>
        }</span><br><br>

        <!-- Section 3: Variables in the same scope with shadowing -->
        // Shadowing in the same scope <br>
        <span class="C3">fn shadowing_example() { <br>
            &nbsp;&nbsp;let z = 2; <br>
            &nbsp;&nbsp;let z = z + 3; // shadowing previous z <br>
            &nbsp;&nbsp;println!("After shadowing, z = {}", z); <br>
        }</span><br><br>

        <!-- Section 4: Calling functions -->
        // Calling functions <br>
        <span class="C4">fn main() { <br>
            &nbsp;&nbsp;inside_function(); <br>
            &nbsp;&nbsp;inside_block(); <br>
            &nbsp;&nbsp;shadowing_example(); <br>
        }</span>
      </code>
    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; Inside function, x = 5</span><br>
      <span class="dot d2"></span><span> &rarr; Inside inner block, y = 20</span><br>
      <span class="dot d2"></span><span> &rarr; Outside inner block, y = 10</span><br>
      <span class="dot d3"></span><span> &rarr; After shadowing, z = 5</span><br>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>let x = 5</code></span>
      <span> – A variable created inside a function can only be used inside that function. 
      Once the function finishes, <code>x</code> disappears. This boundary is called the <em>function scope</em>. 
      Think of scope as the “lifetime” of a variable — when you leave the function, the variable’s memory is cleaned up.</span><br>

      <span class="C2"><code>let y = 20</code></span>
      <span> – This is inside a <em>block</em>. A block in Rust is any piece of code wrapped in curly braces <code>{ }</code>. 
      A block creates its own smaller scope, like a mini-room inside a bigger room. 
      The <code>y</code> inside the block is separate from the <code>y</code> outside. 
      Inside the block, <code>y = 20</code>. Outside, <code>y = 10</code>. They are two different variables with the same name, 
      and the inner one vanishes when the block ends.</span><br>

      <span class="C3"><code>let z = z + 3</code></span>
      <span> – This shows <strong>shadowing</strong>. Shadowing means you declare a new variable with the same name as an old one. 
      The first <code>z</code> is <code>2</code>. Then <code>let z = z + 3</code> creates a brand-new <code>z</code> (value <code>5</code>) 
      that <em>replaces</em> the old one. The old <code>z</code> is dropped, and only the new one exists. 
      Picture writing on a new sticky note and placing it over the old one — the old note is hidden and thrown away, 
      not edited in place.</span><br>

      <span class="C4"><code>fn main()</code></span>
      <span> – The entry point of every Rust program. Rust always looks for <code>main</code> first. 
      Without it, nothing runs (unless you’re writing a library). 
      In this example, <code>main</code> calls the functions so we can see how scope and shadowing work in action.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. A <strong>scope</strong> is the part of the code where a variable exists. 
      Functions, blocks, loops, and conditionals all create new scopes.</span><br>
      <span>2. <strong>Shadowing vs mutability:</strong> 
      - Shadowing (<code>let z = z + 3</code>) makes a brand-new variable. The old one is dropped, and memory is freed.  
      - Mutability (<code>let mut a = 1; a = 2;</code>) keeps the same variable, just updates its value in the same memory slot.  
      Shadowing can also change the type of a variable, while mutability cannot.</span><br>
      <span>3. Shadowing is useful when you want to reuse a name but transform its value step by step, 
      for example: <code>let x = "42"; let x: i32 = x.parse().unwrap();</code> 
      (string → number). This would not be possible with just <code>mut</code>.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>- Rust enforces clear boundaries: variables live only as long as their scope.</span><br>
      <span>- This prevents hidden errors, like accidentally using a variable that should no longer exist.</span><br>
      <span>- Shadowing is Rust’s way of letting you reuse names while keeping transformations safe and predictable.</span><br>
      <span>- Overall, Rust encourages you to think carefully about data lifetimes, which reduces bugs and makes programs more reliable.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: Functions, Parameters, Return Values -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Functions: <code>fn</code>, Parameters, and Return Values</h3>
    <div class="code_block">
      <code>
        <!-- Section 1: Simple function -->
        // Simple function definition <br>
        <span class="C1">fn say_hello() { <br>
            &nbsp;&nbsp;println!("Hello, world!"); <br>
        }</span><br><br>

        <!-- Section 2: Function with parameters -->
        // Function with parameters <br>
        <span class="C2">fn greet(name: &str) { <br>
            &nbsp;&nbsp;println!("Hello, {}!", name); <br>
        }</span><br><br>

        <!-- Section 3: Function with explicit return -->
        // Function with explicit return <br>
        <span class="C3">fn add_explicit(a: i32, b: i32) -> i32 { <br>
            &nbsp;&nbsp;return a + b; <br>
        }</span><br><br>

        <!-- Section 4: Function with implicit return -->
        // Function with implicit return (last expression) <br>
        <span class="C4">fn add_implicit(a: i32, b: i32) -> i32 { <br>
            &nbsp;&nbsp;a + b <br>
        }</span><br><br>

        <!-- Section 5: Calling functions -->
        // Calling functions <br>
        <span class="C5">fn main() { </span><br>
            <span class="C1">&nbsp;&nbsp;say_hello(); </span><br>
            <span class="C2">&nbsp;&nbsp;greet("Alice"); </span><br>
            <span class="C3">&nbsp;&nbsp;let sum1 = add_explicit(5, 7); </span><br>
            <span class="C5">&nbsp;&nbsp;println!("Sum with explicit return: {}", sum1); </span><br>
            <span class="C4">&nbsp;&nbsp;let sum2 = add_implicit(3, 4); </span><br>
            <span class="C5">&nbsp;&nbsp;println!("Sum with implicit return: {}", sum2); <br>
        }</span>
      </code>
    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <span class="dot d1"></span><span> &rarr; Hello, world!</span><br>
      <span class="dot d2"></span><span> &rarr; Hello, Alice!</span><br>
      <span class="dot d3"></span><span> &rarr; Sum with explicit return: 12</span><br>
      <span class="dot d4"></span><span> &rarr; Sum with implicit return: 7</span><br>
      <span class="dot d5"></span><span> &rarr; But called through main</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>fn say_hello()</code></span><span> – A function with no parameters and no return value.</span><br>
      <span class="C2"><code>fn greet(name: &str)</code></span><span> – Takes one parameter called <code>name</code>. Notice that in Rust you must always specify the type (<code>&str</code> here means a string slice).</span><br>
      <span class="C3"><code>fn add_explicit(a: i32, b: i32) -> i32</code></span><span> – Uses the <code>return</code> keyword to send back the sum. This is the “long-form” way.</span><br>
      <span class="C4"><code>fn add_implicit(a: i32, b: i32) -> i32</code></span><span> – Does the same, but without <code>return</code>. In Rust, the last line of a function (if it has no semicolon) is automatically returned.</span><br>
      <span class="C5"><code>fn main()</code></span><span> – The entry point of every Rust program. Rust always starts by looking for <code>main</code>. Without it, nothing runs (unless you are writing a library). Here it calls the other functions and prints their results.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. Both explicit <code>return</code> and implicit return work the same. The difference is style: explicit is clearer in long or complex code, implicit is shorter and common for simple math or logic.</span><br>
      <span>2. In Rust, every parameter must have a type. This makes your code safer and avoids confusion.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>- Rust wants you to be <em>clear about data flow</em>. Parameters are the inputs, return values are the outputs.</span><br>
      <span>- Implicit returns encourage short, readable functions where the last expression is the “answer.”</span><br>
      <span>- Explicit <code>return</code> is useful when you want to exit early or make the return very obvious.</span><br>
      <span>- Overall, Rust functions are designed to be predictable: you always know what goes in and what comes out.</span><br>
      <span>- This makes programs easier to read, safer, and less error-prone compared to languages that guess types or hide return values.</span>
    </div>

  </div>
</template>

<template> <!-- RUST: loops, while, for. -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Loops: <code>loop</code>, <code>while</code>, and <code>for</code></h3>
    <div class="code_block">

      <!-- Section 1: Infinite loop -->
      <code>// Infinite loop (⚠️ press Ctrl + C to stop)</code><br>
      <span class="C1"><code>loop {</code><br>
      <code>&nbsp;&nbsp;println!("This runs forever!");</code><br>
      <code>}</code></span><br><br>

      <!-- Section 2: loop with break -->
      <code>// loop with break returning a value</code><br>
      <span class="C2"><code>let mut counter = 0;</code><br>
      <code>let result = loop {</code><br>
      <code>&nbsp;&nbsp;counter += 1;</code><br>
      <code>&nbsp;&nbsp;if counter == 3 {</code><br>
      <span class="C6"><code>&nbsp;&nbsp;&nbsp;&nbsp;break counter * 2; // returns 6</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>};</code><br>
      <code>println!("Result: {}", result);</code></span><br><br>

      <!-- Section 3: while loop -->
      <code>// while loop countdown</code><br>
      <span class="C3"><code>let mut number = 3;</code><br>
      <code>while number != 0 {</code><br>
      <code>&nbsp;&nbsp;if number == 2 {</code><br>
      <span class="C7"><code>&nbsp;&nbsp;&nbsp;&nbsp;number -= 1; continue; // skips printing 2</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>&nbsp;&nbsp;println!("{}", number);</code><br>
      <code>&nbsp;&nbsp;number -= 1;</code><br>
      <code>}</code><br>
      <code>println!("LIFTOFF!");</code></span><br><br>

      <!-- Section 4: for loop -->
      <code>// for loop over collection</code><br>
      <span class="C4"><code>let arr = [10, 20, 30];</code><br>
      <code>for val in arr.iter() {</code><br>
      <code>&nbsp;&nbsp;if *val == 20 {</code><br>
      <span class="C6"><code>&nbsp;&nbsp;&nbsp;&nbsp;break; // exit loop early</code></span><br>
      <code>&nbsp;&nbsp;}</code><br>
      <code>&nbsp;&nbsp;println!("Value: {}", val);</code><br>
      <code>}</code></span><br><br>

    </div>

    <!-- Example Section -->
    <h3>Example (Outputs):</h3>
    <div class="example">
      <!-- loop (infinite) → no output shown -->
      <span class="dot d2"></span><span> &rarr; Prints: Result: 6</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: 3</span><br>
      <span class="dot d7"></span><span> &rarr; Skips printing 2 (continue)</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: 1</span><br>
      <span class="dot d3"></span><span> &rarr; Prints: LIFTOFF!</span><br>
      <span class="dot d4"></span><span> &rarr; Prints: Value: 10</span><br>
      <span class="dot d6"></span><span> &rarr; Break stops before printing 20 or 30</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1"><code>loop</code></span><span> – Creates an infinite loop unless ended with <span class="C6">break</span>.</span><br>
      <span class="C2"><code>loop ... break value</code></span><span> – A loop can return a value when you <span class="C6">break</span> with an expression. Example: 6.</span><br>
      <span class="C3"><code>while</code></span><span> – Runs while the condition is true. Example: countdown skips printing 2 due to <span class="C7">continue</span>.</span><br>
      <span class="C4"><code>for</code></span><span> – Iterates over a collection. Example: breaks early when hitting 20 using <span class="C6">break</span>.</span><br>
      <span class="C6"><code>break</code></span><span> – Exits the loop immediately. Works in <code>loop</code>, <code>while</code>, and <code>for</code>.</span><br>
      <span class="C7"><code>continue</code></span><span> – Skips the rest of the current iteration and moves to the next. Works in all loop types.</span><br><br>

      <strong>Notes:</strong><br>
      <span>
        1. Infinite loops are rarely needed; always pair with <span class="C6">break</span> for control.<br>
        2. Returning values from loops (<span class="C6">break expr</span>) is unique to Rust.<br>
        3. <span class="C7">continue</span> is useful for filtering values inside loops.<br>
        4. Prefer <code>for</code> for collections, <code>while</code> for conditions, <code>loop</code> for manual control.<br>
        5. <code>arr.iter()</code> creates an iterator of references — you’re borrowing each element instead of copying it. This is efficient and avoids unnecessary allocations.<br>
          - <code>iter()</code> → &T (immutable borrow)<br>
          - <code>iter_mut()</code> → &mut T (mutable borrow)<br>
          - <code>into_iter()</code> → T (moves ownership)<br>
          Rust gives explicit control over access and ownership.<br><br>

        <strong>Concept & Spirit of Rust:</strong><br>
        <span>
          - Rust loops help you <strong>repeat actions safely</strong> and <strong>control exactly how your program runs</strong>.<br>
          - <code>loop</code> runs forever unless you use <span class="C6">break</span>. <code>while</code> runs as long as a condition is true. <code>for</code> iterates over collections. This gives you <strong>flexibility with safety</strong>.<br>
          - Using <span class="C6">break</span> or <span class="C7">continue</span> makes your intentions explicit: you control <strong>when a loop stops</strong> or <strong>skips a step</strong>.<br>
          - Iterators like <code>arr.iter()</code> <strong>borrow elements</strong> instead of copying them, so your code is <strong>efficient and safe</strong>. You don’t accidentally change or duplicate data.<br>
          - Rust encourages you to <strong>think about ownership and borrowing</strong> from the start. Loops and iterators are just one example of how Rust keeps memory and data access predictable.<br>
          - Overall: Rust makes you write code that is <strong>deliberate, clear, and safe</strong>, while still being expressive and powerful. Loops are tools that let you do repetitive tasks <strong>without accidentally creating bugs or memory issues</strong>.<br>
        </span>
    </div>

  </div>
</template>

<template> <!-- Rust: If ... else ... / Switch -> in Rust use -> Match -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Code: If / Else / Match</h3>
    <div class="code_block">
      <!-- If..Else Section -->
      <code>// If..Else Example</code><br>
      <span class="C1"><code>let number = 7;</code></span><br>
      <span class="C2"><code>let result = <br>
        if number % 2 == 0 <br>
        &nbsp;&nbsp;{ "Even" } <br> 
        else <br> 
        &nbsp;&nbsp;{ "Odd" };</code></span><br>
      <span class="C3"><code>println!("Number is {}", result);</code></span><br><br>

      <!-- Match Section -->
      <code>// Match Example</code><br>
      <span class="C4"><code>let day = 3;</code></span><br>
      <span class="C5"><code>let day_name = match day {</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;1 => "Monday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;2 => "Tuesday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;3 => "Wednesday",</code></span><br>
      <span class="C6"><code>
        &nbsp;&nbsp;_ => "Other",</code></span><br>
      <span class="C5"><code>};</code></span><br>
      <span class="C7"><code>println!("Day is {}", day_name);</code></span><br>
    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <span class="dot d2"></span><span> &rarr; Number is Odd</span><br>
      <span class="dot d7"></span><span> &rarr; Day is Wednesday</span><br>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1">let number</span><span> – Declares a variable storing a number.</span><br>
      <span class="C2">if .. else</span><span> – Conditional expression; both branches must return the same type. Here, both return &quot;Even&quot; or &quot;Odd&quot; (strings).</span><br>
      <span class="C3">println!</span><span> – Prints the value of <code>result</code> to the console.</span><br>
      <span class="C4">let day</span><span> – Declares the variable to match against.</span><br>
      <span class="C5">match</span><span> – Pattern matching; similar to a “switch” in other languages but safer and more powerful. Must return same type for all branches.</span><br>
      <span class="C6">branch values</span><span> – Each pattern (1,2,3) maps to a string. The underscore <code>_</code> acts as the default case (like “default” in switch).</span><br>
      <span class="C7">println!</span><span> – Prints <code>day_name</code> to console.</span><br><br>

      <strong>Notes:</strong><br>
      <span>
      <strong class="C2">1. Expression vs Statement:</strong><br>  
        - An <code>expression</code> produces a value (can be assigned to a variable).  <br> 
          Example: <code>let x = 5 + 3;</code> → <code>5 + 3</code> is an expression returning 8.  <br> 
        - A <code>statement</code> performs an action but doesn’t return a value.  <br> 
          Example: <code>let y = 10;</code> is a statement (declares variable, no value returned directly).  <br> 
        - In Rust, <code>if..else</code> is an expression; it returns a value that can be assigned.  <br><br>  

      <strong class="C5">2. Why use match instead of a switch:</strong>  <br> 
        - Rust does not have a traditional “switch” like C/JS.  <br> 
        - <code>match</code> is safer: it forces **exhaustive checking** (all possible cases must be handled).  <br> 
        - Returns a value (like an expression), unlike most switch statements that don’t return values.  <br> 
        - Can match complex patterns (enums, tuples, ranges), which a switch cannot.  <br><br>  

      <strong class="C5">3.  Default case (_)</strong>:  <br> 
        - The underscore <code>_</code> acts as a “catch-all” for any unmatched values.  <br> 
        - Pick it when you want to handle all remaining possibilities not explicitly listed.  <br> 
        - Ensures the match expression is exhaustive; Rust will give a compile error if some value is not covered.  <br><br>  

      <strong class="C2">4. Type requirement:</strong>  <br> 
        - Every branch of <code>if..else</code> or <code>match</code> must return the same type.  <br> 
        - Example: you cannot have one branch return a string and another return a number.  <br><br> 

      <strong>5. Practical tip:</strong>  <br> 
        - Use <code>if..else</code> for simple two-way decisions.  <br> 
        - Use <code>match</code> for multiple options, exhaustive checks, or pattern matching scenarios.  <br> 
      </span><br> 

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>
      - Rust emphasizes **expressions over statements**, meaning many constructs (like <code>if..else</code> and <code>match</code>) produce values that can be used immediately.<br>
      - Pattern matching with <code>match</code> reflects Rust’s philosophy of **safety and exhaustiveness**: you must consider all possible cases, reducing runtime errors.<br>
      - Rust encourages thinking in terms of **ownership, borrowing, and predictable behavior**. Conditionals don’t just control flow—they interact with values and ownership explicitly.<br>
      - The language design nudges you to **write clear, explicit, and memory-safe code**. Each branch returning a consistent type, and exhaustive pattern matching, are examples of this principle.<br>
      - Conceptually, Rust is about **being deliberate**: you explicitly decide how data is handled, how values flow, and how each construct affects program state. This mindset underpins loops, conditionals, and iterators alike.
    </span>
    </div>

  </div>
</template>

<template> <!-- Rust: Operations -->
  <div class="bubble">

    <!-- Code Block -->
    <h3>Rust Code: Operators</h3>
    <div class="code_block">

      <!-- Arithmetic Operators -->
      <code>// Arithmetic Operators</code>
      <span class="C1"><br>
        <code>let sum = 5 + 3;</code><br>
        <code>let difference = 5 - 3;</code><br>
        <code>let product = 5 * 3;</code><br>
        <code>let quotient = 10 / 2;</code><br>
        <code>let remainder = 10 % 3;</code><br>
      </span><br>

      <!-- Assignment Operators -->
      <code>// Assignment Operators</code>
      <span class="C2"><br>
        <code>let mut x = 5;</code><br>
        <code>x += 3;</code><br>
        <code>x -= 2;</code><br>
        <code>x *= 4;</code><br>
        <code>x /= 2;</code><br>
        <code>x %= 2;</code><br>
      </span><br>

      <!-- Comparison Operators -->
      <code>// Comparison Operators</code>
      <span class="C3"><br>
        <code>5 == 5</code><br>
        <code>5 != 3</code><br>
        <code>7 > 3</code><br>
        <code>2 < 5</code><br>
        <code>5 >= 5</code><br>
        <code>3 <= 4</code><br>
      </span><br>

      <!-- Logical Operators -->
       <code>// Logical Operators</code>
      <span class="C4"><br>
        <code>true && false</code><br>
        <code>true || false</code><br>
        <code>!true</code><br>
      </span>

    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <!-- Arithmetic -->
      <span class="dot d1"></span><span> &rarr; 8</span><br>
      <span class="dot d1"></span><span> &rarr; 2</span><br>
      <span class="dot d1"></span><span> &rarr; 15</span><br>
      <span class="dot d1"></span><span> &rarr; 5</span><br>
      <span class="dot d1"></span><span> &rarr; 1</span><br>

      <!-- Assignment -->
      <span class="dot d2"></span><span> &rarr; x = 8 after x += 3</span><br>
      <span class="dot d2"></span><span> &rarr; x = 6 after x -= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 24 after x *= 4</span><br>
      <span class="dot d2"></span><span> &rarr; x = 12 after x /= 2</span><br>
      <span class="dot d2"></span><span> &rarr; x = 0 after x %= 2</span><br>

      <!-- Comparison -->
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>
      <span class="dot d3"></span><span> &rarr; true</span><br>

      <!-- Logical -->
      <span class="dot d4"></span><span> &rarr; false</span><br>
      <span class="dot d4"></span><span> &rarr; true</span><br>
      <span class="dot d4"></span><span> &rarr; false</span><br>
    </div>

      <!-- Explanation Section -->
      <h3>Explanation:</h3>
      <div class="explanation">

        <span class="C1">+</span> adds two numbers. 5 + 3 → 8.<br>
        <span class="C1">-</span> subtracts one number from another. 5 - 3 → 2.<br>
        <span class="C1">*</span> multiplies numbers. 5 * 3 → 15.<br>
        <span class="C1">/</span> divides numbers. 10 / 2 → 5.<br>
        <span class="C1">%</span> gives the remainder of a division. 10 % 3 → 1.<br><br>

        <span class="C2">=</span> assigns a value to a variable.<br>
        <span class="C2">+=</span> adds to the current value. x += 3 adds 3 to x.<br>
        <span class="C2">-=</span> subtracts from the current value.<br>
        <span class="C2">*=</span> multiplies the current value.<br>
        <span class="C2">/=</span> divides the current value.<br>
        <span class="C2">%=</span> replaces the value with the remainder of division.<br>
        Variables must be mutable (mut) to use these operators.<br><br>

        <span class="C3">==</span> checks if two values are equal. 5 == 5 → true.<br>
        <span class="C3">!=</span> checks if two values are not equal. 5 != 3 → true.<br>
        <span class="C3">&gt;</span> checks if the left value is greater than the right. 7 > 3 → true.<br>
        <span class="C3">&lt;</span> checks if the left value is less than the right. 2 < 5 → true.<br>
        <span class="C3">&gt;=</span> checks if the left value is greater than or equal to the right. 5 >= 5 → true.<br>
        <span class="C3">&lt;=</span> checks if the left value is less than or equal to the right. 3 <= 4 → true.<br><br>

        <span class="C4">&&</span> (AND) is true only if both values are true. true && false → false.<br>
        <span class="C4">||</span> (OR) is true if at least one value is true. true || false → true.<br>
        <span class="C4">!</span> (NOT) inverts a boolean value. !true → false.<br><br>

        <strong>Notes:</strong><br>
        Arithmetic operators work on numeric types (i32, f32, etc.).<br>
        Assignment operators require mutable variables.<br>
        Comparison and logical operators return boolean values.<br>
        Rust does not allow mixing numeric types without explicit casting.<br><br>

        <strong>Concept & Spirit of Rust:</strong><br>
        <span>
        - Rust makes you **think about your code carefully**. You must decide when a value can change (mutable) and when it cannot.<br>
        - All operations (math, assignment, comparison, logic) are **safe by default**. Rust won’t do hidden conversions or guesses like some other languages.<br>
        - Using <code>mut</code> shows clearly when a variable is allowed to change. This makes your program easier to understand and less likely to have mistakes.<br>
        - Boolean operations (true/false checks) are clear and predictable — no surprises.<br>
        - The overall idea is to write code that is **explicit, clear, and safe**, so you always know what the program is doing with your data.
      </span>

    </div>

  </div>
</template>

<template> <!-- Rust: Basics -->
  <div class="bubble">

    <h3>Rust Code: Fundamentals:</h3>

    <!-- Code Block -->
    <div class="code_block">
      <!-- Comments -->
      <code>// Single-line comment</code><br>
      <span class="C1"><code>// This is a comment</code><br>
      <code>/* This is a block comment */</code></span><br><br>

      <!-- Variables -->
      <code>// Variables</code><br>
      <span class="C2"><code>let x = 5;          // immutable integer</code><br>
      <code>let mut y = 10;      // mutable integer</code></span><br><br>

      <!-- Data Types -->
      <code>// Data Types</code><br>
      <span class="C3"><code>let my_num: i32 = 5;</code><br>
      <code>let my_double: f64 = 5.99;</code><br>
      <code>let my_letter: char = 'D';</code><br>
      <code>let my_bool: bool = true;</code><br>
      <code>let my_text: &str = "Hello";</code></span><br><br>

      <code>// Type-inferred Data Types</code><br>
      <span class="C4"><code>let my_num = 5;</code><br>
      <code>let my_double = 5.99;</code><br>
      <code>let my_letter = 'D';</code><br>
      <code>let my_bool = true;</code><br>
      <code>let my_text = "Hello";</code></span><br><br>

      <!-- Printing -->
      <code>// Printing Examples</code><br>
      <span class="C5"><code>print!("Hello ");</code><br>
      <code>println!("World!");</code></span><br>
      <span class="C6"><code>let name = "Liam";</code><br>
      <code>println!("Hello, {}", name);</code></span><br>
      <span class="C6"><code>let age = 21;</code><br>
      <code>println!("{} is {} years old", name, age);</code></span><br>
      <span class="C6"><code>println!("First {0}, Second {1}, Again {0}", 10, 20);</code></span><br>
      <span class="C6"><code>println!("Hi {name}", name="Bob");</code></span><br><br>

      <!-- Constants -->
      <code>// Constants</code><br>
      <span class="C7"><code>const MAX_SPEED: i32 = 120;</code><br>
      <code>const PI: f64 = 3.14159;</code><br>
      <code>const MINUTES_PER_HOUR: i32 = 60;</code></span>
    </div>

    <!-- Example Section -->
    <h3>Example:</h3>
    <div class="example">
      <span class="dot d5"></span><span> &rarr; Prints: Hello World!</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hello, Liam</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Liam is 21 years old</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: First 10, Second 20, Again 10</span><br>
      <span class="dot d6"></span><span> &rarr; Prints: Hi Bob</span>
    </div>

    <!-- Explanation Section -->
    <h3>Explanation:</h3>
    <div class="explanation">
      <span class="C1">//, /* */</span><span> – Comments are ignored by the compiler. </span><br>
      <span>Example: You can write </span><code>// explain what x does</code><span> and it won’t affect the program.</span><br><br>

      <span class="C2">let / mut</span><span> – <code>let</code> creates a variable. By default it’s immutable (cannot change). </span><br>
      <span>Example: <code>let x = 5;</code> → trying <code>x = 6;</code> gives an error. </span><br>
      <span>Use <code>let mut y = 10;</code> if you want to change it later (<code>y = 20;</code> works).</span><br><br>

      <span class="C3">Explicit types</span><span> – You can declare the type directly. </span><br>
      <code>let my_num: i32 = 5;</code><span>, <code>let my_double: f64 = 5.99;</code>. </span><br>
      <span>This makes your code clearer and avoids mistakes (like wrong type assumptions).</span><br><br>

      <span class="C4">Type inference</span><span> – If you skip the type, Rust figures it out. </span><br>
      <code>let my_num = 5;</code><span> → compiler knows it’s an <code>i32</code>. </span><br>
      <code>let my_double = 5.99;</code><span> → compiler knows it’s an <code>f64</code>.</span><br>
      <span>You write the type explicitly if you want clarity, or when Rust can’t guess correctly.</span><br><br>

      <span class="C5">print!/println!()</span><span> – <code>print!</code> does not add a new line, <code>println!</code> does. </span><br><br>

      <span class="C6">Placeholders {}</span><span> – Pull values into your string. </span><br>
      <span>Example: </span><code>println!("Hello, {}", name);</code><span> → if <code>name = "Liam"</code>, prints <code>Hello, Liam</code>.</span><br>
      <span>You can use multiple placeholders: </span><code>println!("{} is {}", name, age);</code><br>
      <span>You can reuse positions: </span><code>{0}, {1}</code><br>
      <span>You can also name them: </span><code>println!("Hi {name}", name="Bob");</code><br><br>

      <span class="C7">const</span><span> – Constants never change and must always have a type. </span><br>
      <span>Example: </span><code>const PI: f64 = 3.14159;</code><span> → always the same, anywhere in your code.</span><br><br>

      <strong>Notes:</strong><br>
      <span>1. Variables declared with <code>let</code> are immutable unless <code>mut</code> is used.</span><br>
      <span>2. Constants (<code>const</code>) are always immutable and must have a type.</span><br>
      <span>3. Comparison between constants and variables:</span><br><br>

      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>Feature</th>
          <th>Constant (<code>const</code>)</th>
          <th>Variable (<code>let</code>)</th>
        </tr>
        <tr>
          <td>Can change?</td>
          <td>No</td>
          <td>Yes, if <code>mut</code> is used</td>
        </tr>
        <tr>
          <td>Type required?</td>
          <td>Yes (must be written)</td>
          <td>No (can be inferred)</td>
        </tr>
      </table><br>

      <span>4. Use constants for fixed values like <code>PI</code> or <code>MINUTES_PER_HOUR</code>.</span><br>
      <span>5. Use <code>let</code> / <code>mut</code> for values that may change during program execution.</span><br><br>

      <strong>Concept & Spirit of Rust:</strong><br>
      <span>
      - Rust wants you to **be clear about what can change and what cannot**. Variables are immutable by default, and constants never change — this prevents mistakes.<br>
      - Types are explicit or inferred, but Rust makes you aware of what each value is. This helps avoid unexpected errors.<br>
      - Printing with placeholders shows that Rust separates **data** from **how it’s displayed**, making output safe and predictable.<br>
      - Overall, Rust encourages **writing safe, predictable, and clear code**. Every decision — whether a value can change, how it’s stored, and how it’s printed — is intentional. This is the “spirit” behind Rust.
    </span>
    </div>

  </div>
</template>

<!-- 

If you say so, then create my new skeleton. 
-->